/// <reference types="node" />
import { ChainInfo, EthSignType, Keplr as IKeplr, KeplrIntereactionOptions, KeplrMode, KeplrSignOptions, Key, BroadcastMode, AminoSignResponse, StdSignDoc, OfflineAminoSigner, StdSignature, StdTx, DirectSignResponse, OfflineDirectSigner, ICNSAdr36Signatures, ChainInfoWithoutEndpoints, SecretUtils, SettledResponses, DirectAuxSignResponse, IEthereumProvider, EIP6963ProviderInfo, IStarknetProvider, SupportedPaymentType, IBitcoinProvider, SignPsbtOptions, ChainType as BitcoinChainType, Network as BitcoinNetwork, BitcoinSignMessageType, Inscription } from "@keplr-wallet/types";
import Long from "long";
import EventEmitter from "events";
import type { Call, DeployAccountSignerDetails, InvocationsSignerDetails } from "starknet";
export interface ProxyRequest {
    type: string;
    id: string;
    metaId?: string;
    method: keyof IKeplr;
    args: any[];
    ethereumProviderMethod?: keyof IEthereumProvider;
    bitcoinProviderMethod?: keyof IBitcoinProvider;
}
export interface Result {
    /**
     * NOTE: If `error` is of type `{ module:string; code: number; message: string }`,
     * it should be considered and processed as `KeplrError`.
     */
    error?: string | {
        module: string;
        code: number;
        message: string;
    };
    return?: any;
}
export declare class EthereumProviderRpcError extends Error {
    readonly code: number;
    readonly data?: unknown;
    constructor(code: number, message: string, data?: unknown);
}
export interface ProxyRequestResponse {
    type: "proxy-request-response";
    id: string;
    result: Result | undefined;
}
export declare class Keplr implements IKeplr {
    protected static staticRequestMethod(method: keyof IKeplr, args: any[]): Promise<any>;
    protected requestMethod(method: keyof IKeplr, args: any[]): Promise<any>;
    protected enigmaUtils: Map<string, SecretUtils>;
    readonly version: string;
    readonly mode: KeplrMode;
    defaultOptions: KeplrIntereactionOptions;
    static getKeplr(pingTimeout?: number): Promise<Keplr | undefined>;
    ping(): Promise<void>;
    enable(chainIds: string | string[]): Promise<void>;
    disable(chainIds?: string | string[]): Promise<void>;
    experimentalSuggestChain(chainInfo: ChainInfo): Promise<void>;
    getKey(chainId: string): Promise<Key>;
    getKeysSettled(chainIds: string[]): Promise<SettledResponses<Key>>;
    sendTx(chainId: string, tx: StdTx | Uint8Array, mode: BroadcastMode): Promise<Uint8Array>;
    signAmino(chainId: string, signer: string, signDoc: StdSignDoc, signOptions?: KeplrSignOptions): Promise<AminoSignResponse>;
    signDirect(chainId: string, signer: string, signDoc: {
        bodyBytes?: Uint8Array | null;
        authInfoBytes?: Uint8Array | null;
        chainId?: string | null;
        accountNumber?: Long | null;
    }, signOptions?: KeplrSignOptions): Promise<DirectSignResponse>;
    signDirectAux(chainId: string, signer: string, signDoc: {
        bodyBytes?: Uint8Array | null;
        publicKey?: {
            typeUrl: string;
            value: Uint8Array;
        } | null;
        chainId?: string | null;
        accountNumber?: Long | null;
        sequence?: Long | null;
    }, signOptions?: Exclude<KeplrSignOptions, "preferNoSetFee" | "disableBalanceCheck">): Promise<DirectAuxSignResponse>;
    signArbitrary(chainId: string, signer: string, data: string | Uint8Array): Promise<StdSignature>;
    signICNSAdr36(chainId: string, contractAddress: string, owner: string, username: string, addressChainIds: string[]): Promise<ICNSAdr36Signatures>;
    verifyArbitrary(chainId: string, signer: string, data: string | Uint8Array, signature: StdSignature): Promise<boolean>;
    signEthereum(chainId: string, signer: string, data: string | Uint8Array, type: EthSignType): Promise<Uint8Array>;
    getOfflineSigner(chainId: string, signOptions?: KeplrSignOptions): OfflineAminoSigner & OfflineDirectSigner;
    getOfflineSignerOnlyAmino(chainId: string, signOptions?: KeplrSignOptions): OfflineAminoSigner;
    getOfflineSignerAuto(chainId: string, signOptions?: KeplrSignOptions): Promise<OfflineAminoSigner | OfflineDirectSigner>;
    suggestToken(chainId: string, contractAddress: string, viewingKey?: string): Promise<void>;
    getSecret20ViewingKey(chainId: string, contractAddress: string): Promise<string>;
    getEnigmaPubKey(chainId: string): Promise<Uint8Array>;
    getEnigmaTxEncryptionKey(chainId: string, nonce: Uint8Array): Promise<Uint8Array>;
    enigmaEncrypt(chainId: string, contractCodeHash: string, msg: object): Promise<Uint8Array>;
    enigmaDecrypt(chainId: string, ciphertext: Uint8Array, nonce: Uint8Array): Promise<Uint8Array>;
    getEnigmaUtils(chainId: string): SecretUtils;
    experimentalSignEIP712CosmosTx_v0(chainId: string, signer: string, eip712: {
        types: Record<string, {
            name: string;
            type: string;
        }[] | undefined>;
        domain: Record<string, any>;
        primaryType: string;
    }, signDoc: StdSignDoc, signOptions?: KeplrSignOptions): Promise<AminoSignResponse>;
    getChainInfosWithoutEndpoints(): Promise<ChainInfoWithoutEndpoints[]>;
    changeKeyRingName({ defaultName, editable, }: {
        defaultName: string;
        editable?: boolean;
    }): Promise<string>;
    sendEthereumTx(chainId: string, tx: Uint8Array): Promise<string>;
    suggestERC20(chainId: string, contractAddress: string): Promise<void>;
    getChainInfoWithoutEndpoints(chainId: string): Promise<ChainInfoWithoutEndpoints>;
    getStarknetKey(chainId: string): Promise<{
        name: string;
        hexAddress: string;
        pubKey: Uint8Array;
        address: Uint8Array;
        isNanoLedger: boolean;
    }>;
    getStarknetKeysSettled(chainIds: string[]): Promise<SettledResponses<{
        name: string;
        hexAddress: string;
        pubKey: Uint8Array;
        address: Uint8Array;
        isNanoLedger: boolean;
    }>>;
    signStarknetTx(chainId: string, transactions: Call[], details: InvocationsSignerDetails): Promise<{
        transactions: Call[];
        details: InvocationsSignerDetails;
        signature: string[];
    }>;
    signStarknetDeployAccountTransaction(chainId: string, transaction: DeployAccountSignerDetails): Promise<{
        transaction: DeployAccountSignerDetails;
        signature: string[];
    }>;
    getBitcoinKey(chainId: string): Promise<{
        name: string;
        pubKey: Uint8Array;
        address: string;
        paymentType: SupportedPaymentType;
        isNanoLedger: boolean;
    }>;
    getBitcoinKeysSettled(chainIds: string[]): Promise<SettledResponses<{
        name: string;
        pubKey: Uint8Array;
        address: string;
        paymentType: SupportedPaymentType;
        isNanoLedger: boolean;
    }>>;
    signPsbt(chainId: string, psbtHex: string, options?: SignPsbtOptions): Promise<string>;
    signPsbts(chainId: string, psbtsHexes: string[], options?: SignPsbtOptions): Promise<string[]>;
    __core__getAnalyticsId(): Promise<string>;
    __core__privilageSignAminoWithdrawRewards(chainId: string, signer: string, signDoc: StdSignDoc): Promise<AminoSignResponse>;
    __core__privilageSignAminoDelegate(chainId: string, signer: string, signDoc: StdSignDoc): Promise<AminoSignResponse>;
    __core__privilageSignAminoExecuteCosmWasm(chainId: string, signer: string, signDoc: StdSignDoc): Promise<AminoSignResponse>;
    __core__webpageClosed(): Promise<void>;
    readonly ethereum: EthereumProvider;
    readonly starknet: IStarknetProvider;
    readonly bitcoin: IBitcoinProvider;
}
declare class EthereumProvider extends EventEmitter implements IEthereumProvider {
    protected readonly keplr: Keplr;
    protected readonly eip6963ProviderInfo?: EIP6963ProviderInfo;
    chainId: string | null;
    networkVersion: string | null;
    selectedAddress: string | null;
    isKeplr: boolean;
    isMetaMask: boolean;
    protected _isConnected: boolean;
    protected _currentChainId: string | null;
    constructor(keplr: Keplr);
    protected static requestMethod(method: keyof IEthereumProvider, args: Record<string, any>): Promise<any>;
    protected handleConnect(evmChainId?: number): Promise<void>;
    protected handleDisconnect(): Promise<void>;
    protected handleChainChanged(evmChainId: number): Promise<void>;
    protected handleAccountsChanged(selectedAddress: string): Promise<void>;
    isConnected(): boolean;
    request<T = unknown>({ method, params, chainId, }: {
        method: string;
        params?: readonly unknown[] | Record<string, unknown>;
        chainId?: string;
    }): Promise<T>;
    enable(): Promise<string[]>;
    net_version(): Promise<string>;
}
export declare class BitcoinProvider extends EventEmitter implements IBitcoinProvider {
    protected readonly keplr: Keplr;
    constructor(keplr: Keplr);
    protected static _requestMethod(method: keyof IBitcoinProvider, args: Record<string, any>): Promise<any>;
    getAccounts(): Promise<string[]>;
    requestAccounts(): Promise<string[]>;
    disconnect(): Promise<void>;
    getNetwork(): Promise<BitcoinNetwork>;
    switchNetwork(network: BitcoinNetwork): Promise<BitcoinNetwork>;
    getChain(): Promise<{
        enum: BitcoinChainType;
        name: string;
        network: BitcoinNetwork;
    }>;
    switchChain(chain: BitcoinChainType): Promise<BitcoinChainType>;
    getPublicKey(): Promise<string>;
    getBalance(): Promise<{
        confirmed: number;
        unconfirmed: number;
        total: number;
    }>;
    getInscriptions(offset?: number, limit?: number): Promise<{
        total: number;
        list: Inscription[];
    }>;
    signMessage(message: string, type?: BitcoinSignMessageType): Promise<string>;
    sendBitcoin(to: string, amount: number): Promise<string>;
    pushTx(rawTxHex: string): Promise<string>;
    pushPsbt(psbtHex: string): Promise<string>;
    signPsbt(psbtHex: string, options?: SignPsbtOptions): Promise<string>;
    signPsbts(psbtsHexes: string[], options?: SignPsbtOptions): Promise<string[]>;
    getAddress(): Promise<string>;
    connectWallet(): Promise<string[]>;
}
export {};
