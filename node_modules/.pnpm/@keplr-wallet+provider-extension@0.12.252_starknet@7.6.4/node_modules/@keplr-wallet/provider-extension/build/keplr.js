"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinProvider = exports.Keplr = exports.EthereumProviderRpcError = void 0;
const types_1 = require("@keplr-wallet/types");
const uint8_array_1 = require("./uint8-array");
const deepmerge_1 = __importDefault(require("deepmerge"));
const long_1 = __importDefault(require("long"));
const cosmjs_1 = require("./cosmjs");
const enigma_1 = require("./enigma");
const version_1 = require("./version");
const events_1 = __importDefault(require("events"));
const constants_1 = require("./constants");
class EthereumProviderRpcError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = code;
        this.data = data;
        Object.setPrototypeOf(this, EthereumProviderRpcError.prototype);
    }
}
exports.EthereumProviderRpcError = EthereumProviderRpcError;
class Keplr {
    constructor() {
        this.enigmaUtils = new Map();
        this.version = version_1.BUILD_VERSION;
        this.mode = "extension";
        this.defaultOptions = {};
        this.ethereum = new EthereumProvider(this);
        // TODO: 이거 마지막에 꼭 구현해야한다.
        //       일단은 다른게 더 급해서 일단 any로 처리
        this.starknet = undefined;
        this.bitcoin = new BitcoinProvider(this);
    }
    static staticRequestMethod(method, args) {
        const isMobile = "ReactNativeWebView" in window;
        const postMessage = isMobile
            ? (message) => {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                window.ReactNativeWebView.postMessage(JSON.stringify(message));
            }
            : (message) => {
                window.postMessage(message, window.location.origin);
            };
        const parseMessage = isMobile
            ? (message) => {
                if (message && typeof message === "string") {
                    try {
                        return JSON.parse(message);
                    }
                    catch (_a) {
                        // noop
                    }
                }
                return message;
            }
            : (message) => {
                return message;
            };
        const bytes = new Uint8Array(8);
        const id = Array.from(crypto.getRandomValues(bytes))
            .map((value) => {
            return value.toString(16);
        })
            .join("");
        const proxyRequestType = !window.keplrRequestMetaIdSupport
            ? "proxy-request"
            : `proxy-request${constants_1.metaId ? `-${constants_1.metaId}` : ""}`;
        const proxyMessage = {
            type: proxyRequestType,
            id,
            method,
            args: uint8_array_1.JSONUint8Array.wrap(args),
        };
        return new Promise((resolve, reject) => {
            const receiveResponse = (e) => {
                const proxyResponse = parseMessage(e.data);
                if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
                    return;
                }
                if (proxyResponse.id !== id) {
                    return;
                }
                window.removeEventListener("message", receiveResponse);
                const result = uint8_array_1.JSONUint8Array.unwrap(proxyResponse.result);
                if (!result) {
                    reject(new Error("Result is null"));
                    return;
                }
                if (result.error) {
                    reject(new Error(result.error));
                    return;
                }
                resolve(result.return);
            };
            window.addEventListener("message", receiveResponse);
            postMessage(proxyMessage);
        });
    }
    requestMethod(method, args) {
        return Keplr.staticRequestMethod(method, args);
    }
    static getKeplr(pingTimeout = 1500) {
        return __awaiter(this, void 0, void 0, function* () {
            yield waitDocumentReady();
            const isMobile = "ReactNativeWebView" in window;
            const isFirefox = (() => {
                if (typeof navigator !== "undefined" && "userAgent" in navigator) {
                    return navigator.userAgent.includes("Firefox");
                }
                return false;
            })();
            if (!isMobile &&
                !isFirefox &&
                window.keplrRequestMetaIdSupport == null) {
                return undefined;
            }
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    resolve(undefined);
                }, pingTimeout);
                Keplr.staticRequestMethod("ping", [])
                    .then(() => {
                    clearTimeout(timeout);
                    resolve(new Keplr());
                })
                    .catch((e) => {
                    var _a;
                    // if legacy version.
                    if ((_a = e === null || e === void 0 ? void 0 : e.message) === null || _a === void 0 ? void 0 : _a.includes("Invalid method: ping")) {
                        clearTimeout(timeout);
                        resolve(new Keplr());
                    }
                    else {
                        reject(e);
                    }
                });
            });
        });
    }
    ping() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.requestMethod("ping", []);
        });
    }
    enable(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.requestMethod("enable", [chainIds]);
        });
    }
    disable(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.requestMethod("disable", [chainIds]);
        });
    }
    experimentalSuggestChain(chainInfo) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (chainInfo.hideInUI) {
                throw new Error("hideInUI is not allowed");
            }
            if (((_a = chainInfo.features) === null || _a === void 0 ? void 0 : _a.includes("stargate")) ||
                ((_b = chainInfo.features) === null || _b === void 0 ? void 0 : _b.includes("no-legacy-stdTx"))) {
                console.warn("“stargate”, “no-legacy-stdTx” feature has been deprecated. The launchpad is no longer supported, thus works without the two features. We would keep the aforementioned two feature for a while, but the upcoming update would potentially cause errors. Remove the two feature.");
            }
            yield this.requestMethod("experimentalSuggestChain", [chainInfo]);
        });
    }
    getKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getKey", [chainId]);
        });
    }
    getKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getKeysSettled", [chainIds]);
        });
    }
    sendTx(chainId, tx, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!("length" in tx)) {
                console.warn("Do not send legacy std tx via `sendTx` API. We now only support protobuf tx. The usage of legeacy std tx would throw an error in the near future.");
            }
            return yield this.requestMethod("sendTx", [chainId, tx, mode]);
        });
    }
    signAmino(chainId, signer, signDoc, signOptions = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signAmino", [
                chainId,
                signer,
                signDoc,
                (0, deepmerge_1.default)((_a = this.defaultOptions.sign) !== null && _a !== void 0 ? _a : {}, signOptions),
            ]);
        });
    }
    signDirect(chainId, signer, signDoc, signOptions = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.requestMethod("signDirect", [
                chainId,
                signer,
                // We can't send the `Long` with remaing the type.
                // Receiver should change the `string` to `Long`.
                {
                    bodyBytes: signDoc.bodyBytes,
                    authInfoBytes: signDoc.authInfoBytes,
                    chainId: signDoc.chainId,
                    accountNumber: signDoc.accountNumber
                        ? signDoc.accountNumber.toString()
                        : null,
                },
                (0, deepmerge_1.default)((_a = this.defaultOptions.sign) !== null && _a !== void 0 ? _a : {}, signOptions),
            ]);
            const signed = result.signed;
            return {
                signed: {
                    bodyBytes: signed.bodyBytes,
                    authInfoBytes: signed.authInfoBytes,
                    chainId: signed.chainId,
                    // We can't send the `Long` with remaing the type.
                    // Sender should change the `Long` to `string`.
                    accountNumber: long_1.default.fromString(signed.accountNumber),
                },
                signature: result.signature,
            };
        });
    }
    signDirectAux(chainId, signer, signDoc, signOptions = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.requestMethod("signDirectAux", [
                chainId,
                signer,
                // We can't send the `Long` with remaing the type.
                // Receiver should change the `string` to `Long`.
                {
                    bodyBytes: signDoc.bodyBytes,
                    publicKey: signDoc.publicKey,
                    chainId: signDoc.chainId,
                    accountNumber: signDoc.accountNumber
                        ? signDoc.accountNumber.toString()
                        : null,
                    sequence: signDoc.sequence ? signDoc.sequence.toString() : null,
                },
                (0, deepmerge_1.default)({
                    preferNoSetMemo: (_a = this.defaultOptions.sign) === null || _a === void 0 ? void 0 : _a.preferNoSetMemo,
                }, signOptions),
            ]);
            const signed = result.signed;
            return {
                signed: {
                    bodyBytes: signed.bodyBytes,
                    publicKey: signed.publicKey || undefined,
                    chainId: signed.chainId,
                    // We can't send the `Long` with remaing the type.
                    // Sender should change the `Long` to `string`.
                    accountNumber: long_1.default.fromString(signed.accountNumber),
                    sequence: long_1.default.fromString(signed.sequence),
                },
                signature: result.signature,
            };
        });
    }
    signArbitrary(chainId, signer, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signArbitrary", [chainId, signer, data]);
        });
    }
    signICNSAdr36(chainId, contractAddress, owner, username, addressChainIds) {
        return this.requestMethod("signICNSAdr36", [
            chainId,
            contractAddress,
            owner,
            username,
            addressChainIds,
        ]);
    }
    verifyArbitrary(chainId, signer, data, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("verifyArbitrary", [
                chainId,
                signer,
                data,
                signature,
            ]);
        });
    }
    signEthereum(chainId, signer, data, type) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signEthereum", [
                chainId,
                signer,
                data,
                type,
            ]);
        });
    }
    getOfflineSigner(chainId, signOptions) {
        return new cosmjs_1.CosmJSOfflineSigner(chainId, this, signOptions);
    }
    getOfflineSignerOnlyAmino(chainId, signOptions) {
        return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this, signOptions);
    }
    getOfflineSignerAuto(chainId, signOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield this.getKey(chainId);
            if (key.isNanoLedger) {
                return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this, signOptions);
            }
            return new cosmjs_1.CosmJSOfflineSigner(chainId, this, signOptions);
        });
    }
    suggestToken(chainId, contractAddress, viewingKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("suggestToken", [
                chainId,
                contractAddress,
                viewingKey,
            ]);
        });
    }
    getSecret20ViewingKey(chainId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getSecret20ViewingKey", [
                chainId,
                contractAddress,
            ]);
        });
    }
    getEnigmaPubKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getEnigmaPubKey", [chainId]);
        });
    }
    getEnigmaTxEncryptionKey(chainId, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getEnigmaTxEncryptionKey", [
                chainId,
                nonce,
            ]);
        });
    }
    enigmaEncrypt(chainId, contractCodeHash, 
    // eslint-disable-next-line @typescript-eslint/ban-types
    msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("enigmaEncrypt", [
                chainId,
                contractCodeHash,
                msg,
            ]);
        });
    }
    enigmaDecrypt(chainId, ciphertext, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("enigmaDecrypt", [
                chainId,
                ciphertext,
                nonce,
            ]);
        });
    }
    getEnigmaUtils(chainId) {
        if (this.enigmaUtils.has(chainId)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.enigmaUtils.get(chainId);
        }
        const enigmaUtils = new enigma_1.KeplrEnigmaUtils(chainId, this);
        this.enigmaUtils.set(chainId, enigmaUtils);
        return enigmaUtils;
    }
    experimentalSignEIP712CosmosTx_v0(chainId, signer, eip712, signDoc, signOptions = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("experimentalSignEIP712CosmosTx_v0", [
                chainId,
                signer,
                eip712,
                signDoc,
                (0, deepmerge_1.default)((_a = this.defaultOptions.sign) !== null && _a !== void 0 ? _a : {}, signOptions),
            ]);
        });
    }
    getChainInfosWithoutEndpoints() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getChainInfosWithoutEndpoints", []);
        });
    }
    changeKeyRingName({ defaultName, editable = true, }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("changeKeyRingName", [
                { defaultName, editable },
            ]);
        });
    }
    sendEthereumTx(chainId, tx) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("sendEthereumTx", [chainId, tx]);
        });
    }
    suggestERC20(chainId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("suggestERC20", [chainId, contractAddress]);
        });
    }
    getChainInfoWithoutEndpoints(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getChainInfoWithoutEndpoints", [chainId]);
        });
    }
    getStarknetKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getStarknetKey", [chainId]);
        });
    }
    getStarknetKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getStarknetKeysSettled", [chainIds]);
        });
    }
    signStarknetTx(chainId, transactions, details) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signStarknetTx", [
                chainId,
                transactions,
                details,
            ]);
        });
    }
    signStarknetDeployAccountTransaction(chainId, transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signStarknetDeployAccountTransaction", [
                chainId,
                transaction,
            ]);
        });
    }
    getBitcoinKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getBitcoinKey", [chainId]);
        });
    }
    getBitcoinKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getBitcoinKeysSettled", [chainIds]);
        });
    }
    signPsbt(chainId, psbtHex, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signPsbt", [chainId, psbtHex, options]);
        });
    }
    signPsbts(chainId, psbtsHexes, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signPsbts", [
                chainId,
                psbtsHexes,
                options,
            ]);
        });
    }
    __core__getAnalyticsId() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("__core__getAnalyticsId", []);
        });
    }
    __core__privilageSignAminoWithdrawRewards(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("__core__privilageSignAminoWithdrawRewards", [chainId, signer, signDoc]);
        });
    }
    __core__privilageSignAminoDelegate(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("__core__privilageSignAminoDelegate", [chainId, signer, signDoc]);
        });
    }
    __core__privilageSignAminoExecuteCosmWasm(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("__core__privilageSignAminoExecuteCosmWasm", [chainId, signer, signDoc]);
        });
    }
    __core__webpageClosed() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("__core__webpageClosed", []);
        });
    }
}
exports.Keplr = Keplr;
const waitDocumentReady = () => {
    if (document.readyState === "complete") {
        return Promise.resolve();
    }
    return new Promise((resolve) => {
        const documentStateChange = (event) => {
            if (event.target &&
                event.target.readyState === "complete") {
                resolve();
                document.removeEventListener("readystatechange", documentStateChange);
            }
        };
        document.addEventListener("readystatechange", documentStateChange);
    });
};
class EthereumProvider extends events_1.default {
    constructor(keplr) {
        super();
        this.keplr = keplr;
        this.eip6963ProviderInfo = {
            uuid: crypto.randomUUID(),
            name: "Keplr",
            rdns: "app.keplr",
            icon: `data:image/png;base64,${constants_1.KeplrLogoBase64}`,
        };
        // It must be in the hexadecimal format used in EVM-based chains, not the format used in Tendermint nodes.
        this.chainId = null;
        // It must be in the decimal format of chainId.
        this.networkVersion = null;
        this.selectedAddress = null;
        this.isKeplr = true;
        this.isMetaMask = true;
        this._isConnected = false;
        this._currentChainId = null;
        window.addEventListener("keplr_keystorechange", () => __awaiter(this, void 0, void 0, function* () {
            if (this._currentChainId) {
                const chainInfo = yield keplr.getChainInfoWithoutEndpoints(this._currentChainId);
                if (chainInfo) {
                    const selectedAddress = (yield keplr.getKey(this._currentChainId))
                        .ethereumHexAddress;
                    this.handleAccountsChanged(selectedAddress);
                }
            }
        }));
        window.addEventListener("keplr_chainChanged", (event) => {
            const origin = event.detail.origin;
            if (origin === window.location.origin) {
                const evmChainId = event.detail.evmChainId;
                this.handleChainChanged(evmChainId);
            }
        });
        window.addEventListener("keplr_ethSubscription", (event) => {
            var _a;
            const origin = event.detail.origin;
            const providerId = event.detail.providerId;
            if (origin === window.location.origin &&
                providerId === ((_a = this.eip6963ProviderInfo) === null || _a === void 0 ? void 0 : _a.uuid)) {
                const data = event.detail.data;
                this.emit("message", {
                    type: "eth_subscription",
                    data,
                });
            }
        });
        if (this.eip6963ProviderInfo) {
            const announceEvent = new CustomEvent(types_1.EIP6963EventNames.Announce, {
                detail: Object.freeze({
                    info: this.eip6963ProviderInfo,
                    provider: this,
                }),
            });
            window.addEventListener(types_1.EIP6963EventNames.Request, () => window.dispatchEvent(announceEvent));
            window.dispatchEvent(announceEvent);
        }
    }
    static requestMethod(method, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const isMobile = "ReactNativeWebView" in window;
            const postMessage = isMobile
                ? (message) => {
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    window.ReactNativeWebView.postMessage(JSON.stringify(message));
                }
                : (message) => {
                    window.postMessage(message, window.location.origin);
                };
            const parseMessage = isMobile
                ? (message) => {
                    if (message && typeof message === "string") {
                        try {
                            return JSON.parse(message);
                        }
                        catch (_a) {
                            // noop
                        }
                    }
                    return message;
                }
                : (message) => {
                    return message;
                };
            const bytes = new Uint8Array(8);
            const id = Array.from(crypto.getRandomValues(bytes))
                .map((value) => {
                return value.toString(16);
            })
                .join("");
            const proxyRequestType = !window.keplrRequestMetaIdSupport
                ? "proxy-request"
                : `proxy-request${constants_1.metaId ? `-${constants_1.metaId}` : ""}`;
            const proxyMessage = {
                type: proxyRequestType,
                id,
                method: "ethereum",
                args: uint8_array_1.JSONUint8Array.wrap(args),
                ethereumProviderMethod: method,
            };
            return new Promise((resolve, reject) => {
                const receiveResponse = (e) => {
                    const proxyResponse = parseMessage(e.data);
                    if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
                        return;
                    }
                    if (proxyResponse.id !== id) {
                        return;
                    }
                    window.removeEventListener("message", receiveResponse);
                    const result = uint8_array_1.JSONUint8Array.unwrap(proxyResponse.result);
                    if (!result) {
                        reject(new Error("Result is null"));
                        return;
                    }
                    if (result.error) {
                        const error = result.error;
                        reject(error.code && !error.module
                            ? new EthereumProviderRpcError(error.code, error.message, error.data)
                            : new Error(error));
                        return;
                    }
                    resolve(result.return);
                };
                window.addEventListener("message", receiveResponse);
                postMessage(proxyMessage);
            });
        });
    }
    handleConnect(evmChainId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._isConnected) {
                const { currentEvmChainId, currentChainId, selectedAddress } = yield EthereumProvider.requestMethod("request", Object.assign({ method: "keplr_connect" }, (evmChainId && { params: [evmChainId] })));
                this._isConnected = true;
                this._currentChainId = currentChainId;
                this.chainId = `0x${currentEvmChainId.toString(16)}`;
                this.networkVersion = currentEvmChainId.toString(10);
                this.selectedAddress = selectedAddress;
                this.emit("connect", { chainId: this.chainId });
            }
        });
    }
    handleDisconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isConnected) {
                yield EthereumProvider.requestMethod("request", {
                    method: "keplr_disconnect",
                });
                this._isConnected = false;
                this.chainId = null;
                this.selectedAddress = null;
                this.networkVersion = null;
                this.emit("disconnect");
            }
        });
    }
    handleChainChanged(evmChainId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handleConnect(evmChainId);
            const evmChainIdHex = `0x${evmChainId.toString(16)}`;
            this.emit("chainChanged", evmChainIdHex);
        });
    }
    handleAccountsChanged(selectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isConnected) {
                this.selectedAddress = selectedAddress;
                this.emit("accountsChanged", [selectedAddress]);
            }
        });
    }
    isConnected() {
        return this._isConnected;
    }
    request({ method, params, chainId, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._isConnected) {
                if (method === "eth_accounts") {
                    return [];
                }
                yield this.handleConnect();
            }
            return yield EthereumProvider.requestMethod("request", {
                method,
                params,
                providerId: (_a = this.eip6963ProviderInfo) === null || _a === void 0 ? void 0 : _a.uuid,
                chainId,
            });
        });
    }
    enable() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield EthereumProvider.requestMethod("request", {
                method: "eth_requestAccounts",
            });
        });
    }
    net_version() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield EthereumProvider.requestMethod("request", {
                method: "net_version",
            });
        });
    }
}
class BitcoinProvider extends events_1.default {
    constructor(keplr) {
        super();
        this.keplr = keplr;
    }
    static _requestMethod(method, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const isMobile = "ReactNativeWebView" in window;
            const postMessage = isMobile
                ? (message) => {
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    window.ReactNativeWebView.postMessage(JSON.stringify(message));
                }
                : (message) => {
                    window.postMessage(message, window.location.origin);
                };
            const parseMessage = isMobile
                ? (message) => {
                    if (message && typeof message === "string") {
                        try {
                            return JSON.parse(message);
                        }
                        catch (_a) {
                            // noop
                        }
                    }
                    return message;
                }
                : (message) => {
                    return message;
                };
            const bytes = new Uint8Array(8);
            const id = Array.from(crypto.getRandomValues(bytes))
                .map((value) => {
                return value.toString(16);
            })
                .join("");
            const proxyRequestType = !window.keplrRequestMetaIdSupport
                ? "proxy-request"
                : `proxy-request${constants_1.metaId ? `-${constants_1.metaId}` : ""}`;
            const proxyMessage = {
                type: proxyRequestType,
                id,
                method: "bitcoin",
                args: uint8_array_1.JSONUint8Array.wrap(args),
                bitcoinProviderMethod: method,
            };
            return new Promise((resolve, reject) => {
                const receiveResponse = (e) => {
                    const proxyResponse = parseMessage(e.data);
                    if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
                        return;
                    }
                    if (proxyResponse.id !== id) {
                        return;
                    }
                    window.removeEventListener("message", receiveResponse);
                    const result = uint8_array_1.JSONUint8Array.unwrap(proxyResponse.result);
                    if (!result) {
                        reject(new Error("Result is null"));
                        return;
                    }
                    if (result.error) {
                        reject(new Error(result.error));
                        return;
                    }
                    resolve(result.return);
                };
                window.addEventListener("message", receiveResponse);
                postMessage(proxyMessage);
            });
        });
    }
    getAccounts() {
        return BitcoinProvider._requestMethod("getAccounts", []);
    }
    requestAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("requestAccounts", []);
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("disconnect", []);
        });
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("getNetwork", []);
        });
    }
    switchNetwork(network) {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("switchNetwork", [network]);
        });
    }
    getChain() {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("getChain", []);
        });
    }
    switchChain(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("switchChain", [chain]);
        });
    }
    getPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("getPublicKey", []);
        });
    }
    getBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("getBalance", []);
        });
    }
    getInscriptions(offset, limit) {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("getInscriptions", [offset, limit]);
        });
    }
    signMessage(message, type) {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("signMessage", [message, type]);
        });
    }
    sendBitcoin(to, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("sendBitcoin", [to, amount]);
        });
    }
    pushTx(rawTxHex) {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("pushTx", [rawTxHex]);
        });
    }
    pushPsbt(psbtHex) {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("pushPsbt", [psbtHex]);
        });
    }
    signPsbt(psbtHex, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("signPsbt", [psbtHex, options]);
        });
    }
    signPsbts(psbtsHexes, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return BitcoinProvider._requestMethod("signPsbts", [psbtsHexes, options]);
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const accounts = yield this.getAccounts();
            return accounts[0];
        });
    }
    connectWallet() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestAccounts();
        });
    }
}
exports.BitcoinProvider = BitcoinProvider;
//# sourceMappingURL=keplr.js.map