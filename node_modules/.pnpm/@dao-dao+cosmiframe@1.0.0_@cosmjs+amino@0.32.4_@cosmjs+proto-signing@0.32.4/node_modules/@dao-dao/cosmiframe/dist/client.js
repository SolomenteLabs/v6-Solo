"use strict";var N=Object.defineProperty;var ee=Object.getOwnPropertyDescriptor;var te=Object.getOwnPropertyNames;var ne=Object.prototype.hasOwnProperty;var re=(n,e,t)=>e in n?N(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var o=(n,e)=>N(n,"name",{value:e,configurable:!0});var ie=(n,e)=>{for(var t in e)N(n,t,{get:e[t],enumerable:!0})},se=(n,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of te(e))!ne.call(n,i)&&i!==t&&N(n,i,{get:()=>e[i],enumerable:!(r=ee(e,i))||r.enumerable});return n};var oe=n=>se(N({},"__esModule",{value:!0}),n);var A=(n,e,t)=>(re(n,typeof e!="symbol"?e+"":e,t),t),z=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)};var a=(n,e,t)=>(z(n,e,"read from private field"),t?t.call(n):e.get(n)),O=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},v=(n,e,t,r)=>(z(n,e,"write to private field"),r?r.call(n,t):e.set(n,t),t);var ae={};ie(ae,{Cosmiframe:()=>k});module.exports=oe(ae);var K=class K extends Error{constructor(e){super(e),this.name="CosmiframeTimeoutError"}};o(K,"CosmiframeTimeoutError");var x=K;var B=require("uuid");var J="UNSAFE_ALLOW_ANY_ORIGIN",p=o((n,e,t)=>new Promise((r,i)=>{let h=null,I=(0,B.v4)(),l=o(({origin:d,source:G,data:E})=>{!$(e,d)||G!==window.parent||E.id!==I||(window.removeEventListener("message",l),h!==null&&clearTimeout(h),E.type==="success"?r({result:E.response,origin:d}):i(new Error(E.error)))},"listener");window.addEventListener("message",l);try{let d={...n,id:I};window.parent.postMessage(d,"*")}catch(d){window.removeEventListener("message",l),i(d)}t&&(h=setTimeout(()=>{window.removeEventListener("message",l),i(new x(`Timed out after ${t}ms waiting for parent to respond.`))},t))}),"callParentMethod"),U=o(n=>{if(!n||n.type==="error")return{type:"error",error:n&&n.type==="error"&&n.error||"Handled by outer wallet."};if(n.type==="success")return{type:"success",response:n.value}},"processOverrideHandler"),Q=o(()=>typeof window<"u"&&window.self!==window.parent,"isInIframe"),$=o((n,e)=>n.some(t=>t==="*"||typeof t=="string"&&e===t||t instanceof RegExp&&t.test(e)),"isOriginAllowed");var M,R=class R{constructor(e,t){A(this,"chainId");O(this,M,void 0);this.chainId=e,v(this,M,t)}async getAccounts(){return(await p({method:"getAccounts",params:[],chainId:this.chainId,signerType:"direct"},a(this,M))).result}async signDirect(e,t){return(await p({method:"signDirect",params:[e,t],chainId:this.chainId,signerType:"direct"},a(this,M))).result}};M=new WeakMap,o(R,"CosmiframeDirectSigner");var D=R,T,Y=class Y{constructor(e,t){A(this,"chainId");O(this,T,void 0);this.chainId=e,v(this,T,t)}async getAccounts(){return(await p({method:"getAccounts",params:[],chainId:this.chainId,signerType:"amino"},a(this,T))).result}async signAmino(e,t){return(await p({method:"signAmino",params:[e,t],chainId:this.chainId,signerType:"amino"},a(this,T))).result}};T=new WeakMap,o(Y,"CosmiframeAminoSigner");var W=Y,u,F=class F{constructor(e,t){A(this,"chainId");O(this,u,void 0);this.chainId=e,v(this,u,t)}async getAccounts(){try{return(await p({method:"getAccounts",params:[],chainId:this.chainId,signerType:"amino"},a(this,u))).result}catch{return(await p({method:"getAccounts",params:[],chainId:this.chainId,signerType:"direct"},a(this,u))).result}}async signDirect(e,t){return(await p({method:"signDirect",params:[e,t],chainId:this.chainId,signerType:"direct"},a(this,u))).result}async signAmino(e,t){return(await p({method:"signAmino",params:[e,t],chainId:this.chainId,signerType:"amino"},a(this,u))).result}};u=new WeakMap,o(F,"CosmiframeEitherSigner");var _=F;var w;(function(n){n.IsCosmiframe="isCosmiframe",n.GetMetadata="getMetadata"})(w||(w={}));var m,H=class H{constructor(e){O(this,m,void 0);A(this,"p");if(!e.length)throw new Error("You must explicitly allow parent origins.");if(e.includes("*"))throw new Error("It is very unsafe to allow all origins because a controlling app has the power to manipulate messages before they are signed. If you really want to do this, pass in `UNSAFE_ALLOW_ANY_ORIGIN`.");v(this,m,e.includes(J)?["*"]:[...e]),this.p=new Proxy({getEnigmaUtils:t=>({getPubkey:()=>this.p.getEnigmaPubKey(t),decrypt:(...r)=>this.p.enigmaDecrypt(t,...r),encrypt:(...r)=>this.p.enigmaEncrypt(t,...r),getTxEncryptionKey:(...r)=>this.p.getEnigmaTxEncryptionKey(t,...r)})},{get:(t,r)=>r in t&&typeof t[r]!="function"?t[r]:(...i)=>r in t&&typeof t[r]=="function"?t[r](...i):this.callParentMethod({method:r.toString(),params:i}).then(({result:h})=>h)})}callParentMethod(e,t){return p(e,a(this,m),t)}async isReady(){if(!Q())return!1;try{let{origin:e,result:t}=await this.callParentMethod({internal:!0,method:w.IsCosmiframe,params:[]},500);return e||t}catch(e){if(e instanceof x)return!1;throw e}}async getMetadata(){return(await this.callParentMethod({internal:!0,method:w.GetMetadata,params:[]},500)).result}getKeplrClient(){let e=new Proxy({version:"cosmiframe",mode:"extension",defaultOptions:{},getOfflineSigner:this.getOfflineSigner.bind(this),getOfflineSignerOnlyAmino:this.getOfflineSignerAmino.bind(this),getOfflineSignerAuto:t=>Promise.resolve(this.getOfflineSigner(t)),getEnigmaUtils:t=>({getPubkey:()=>e.getEnigmaPubKey(t),decrypt:(...r)=>e.enigmaDecrypt(t,...r),encrypt:(...r)=>e.enigmaEncrypt(t,...r),getTxEncryptionKey:(...r)=>e.getEnigmaTxEncryptionKey(t,...r)})},{get:(t,r)=>r in t&&typeof t[r]!="function"?t[r]:(...i)=>r in t&&typeof t[r]=="function"?t[r](...i):this.callParentMethod({method:r.toString(),params:i}).then(({result:h})=>h)});return e}getOfflineSigner(e){return new _(e,a(this,m))}getOfflineSignerAmino(e){return new W(e,a(this,m))}getOfflineSignerDirect(e){return new D(e,a(this,m))}static listen(e){let{iframe:t,target:r,getOfflineSignerDirect:i,getOfflineSignerAmino:h,nonSignerOverrides:I,signerOverrides:l,origins:d,metadata:G}=e,E=d?.length?d:["*"],q={[w.IsCosmiframe]:()=>!0,[w.GetMetadata]:()=>G||null},C=o(async({source:V,origin:b,data:y})=>{if(!t.contentWindow)throw new Error("Iframe contentWindow does not exist.");if(V!==t.contentWindow||!$(E,b)||!y||typeof y!="object"||!("id"in y)||!("method"in y)||!("params"in y))return;let{id:X,params:S,chainId:L,signType:Z,internal:j}=y,{method:s,signerType:P}=y;P||(P=Z),s=s.replace(/^signer:/,"");let f;try{if(j){if(typeof q[s]!="function")throw new Error(`Unknown internal method: ${s}`);f={type:"success",response:await q[s](...S)}}else if(P){if(!L)throw new Error("Missing chainId in signer message request");let c=typeof l=="function"?await l(L):l;if(c&&s in c){let g=U(await c[s](...S));g&&(f=g)}if(!f){let g=P==="direct"?await i(L):await h(L);if(!(s in g)||typeof g[s]!="function")throw new Error(`No ${P} signer method '${s}' for chain ID '${L}'.`);f={type:"success",response:await g[s](...S)}}}else{let c=typeof I=="function"?await I():I;if(c&&s in c){let g=U(await c[s](...S));g&&(f=g)}if(!f){if(!(s in r)||typeof r[s]!="function")throw new Error(`No method '${s}' on target.`);f={type:"success",response:await r[s](...S)}}}}catch(c){f={type:"error",error:c instanceof Error?c.message:`${c}`}}t.contentWindow?.postMessage({...f,id:X},b)},"listener");return window.addEventListener("message",C),()=>window.removeEventListener("message",C)}};m=new WeakMap,o(H,"Cosmiframe");var k=H;0&&(module.exports={Cosmiframe});
//# sourceMappingURL=client.js.map