var C=Object.defineProperty;var j=(n,t,e)=>t in n?C(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var s=(n,t)=>C(n,"name",{value:t,configurable:!0});var A=(n,t,e)=>(j(n,typeof t!="symbol"?t+"":t,e),e),b=(n,t,e)=>{if(!t.has(n))throw TypeError("Cannot "+e)};var o=(n,t,e)=>(b(n,t,"read from private field"),e?e.call(n):t.get(n)),O=(n,t,e)=>{if(t.has(n))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(n):t.set(n,e)},v=(n,t,e,r)=>(b(n,t,"write to private field"),r?r.call(n,e):t.set(n,e),e);var G=class G extends Error{constructor(t){super(t),this.name="CosmiframeTimeoutError"}};s(G,"CosmiframeTimeoutError");var x=G;import{v4 as ee}from"uuid";var z="UNSAFE_ALLOW_ANY_ORIGIN",p=s((n,t,e)=>new Promise((r,c)=>{let h=null,I=ee(),l=s(({origin:d,source:_,data:E})=>{!U(t,d)||_!==window.parent||E.id!==I||(window.removeEventListener("message",l),h!==null&&clearTimeout(h),E.type==="success"?r({result:E.response,origin:d}):c(new Error(E.error)))},"listener");window.addEventListener("message",l);try{let d={...n,id:I};window.parent.postMessage(d,"*")}catch(d){window.removeEventListener("message",l),c(d)}e&&(h=setTimeout(()=>{window.removeEventListener("message",l),c(new x(`Timed out after ${e}ms waiting for parent to respond.`))},e))}),"callParentMethod"),K=s(n=>{if(!n||n.type==="error")return{type:"error",error:n&&n.type==="error"&&n.error||"Handled by outer wallet."};if(n.type==="success")return{type:"success",response:n.value}},"processOverrideHandler"),B=s(()=>typeof window<"u"&&window.self!==window.parent,"isInIframe"),U=s((n,t)=>n.some(e=>e==="*"||typeof e=="string"&&t===e||e instanceof RegExp&&e.test(t)),"isOriginAllowed");var M,$=class ${constructor(t,e){A(this,"chainId");O(this,M,void 0);this.chainId=t,v(this,M,e)}async getAccounts(){return(await p({method:"getAccounts",params:[],chainId:this.chainId,signerType:"direct"},o(this,M))).result}async signDirect(t,e){return(await p({method:"signDirect",params:[t,e],chainId:this.chainId,signerType:"direct"},o(this,M))).result}};M=new WeakMap,s($,"CosmiframeDirectSigner");var P=$,T,R=class R{constructor(t,e){A(this,"chainId");O(this,T,void 0);this.chainId=t,v(this,T,e)}async getAccounts(){return(await p({method:"getAccounts",params:[],chainId:this.chainId,signerType:"amino"},o(this,T))).result}async signAmino(t,e){return(await p({method:"signAmino",params:[t,e],chainId:this.chainId,signerType:"amino"},o(this,T))).result}};T=new WeakMap,s(R,"CosmiframeAminoSigner");var D=R,u,Y=class Y{constructor(t,e){A(this,"chainId");O(this,u,void 0);this.chainId=t,v(this,u,e)}async getAccounts(){try{return(await p({method:"getAccounts",params:[],chainId:this.chainId,signerType:"amino"},o(this,u))).result}catch{return(await p({method:"getAccounts",params:[],chainId:this.chainId,signerType:"direct"},o(this,u))).result}}async signDirect(t,e){return(await p({method:"signDirect",params:[t,e],chainId:this.chainId,signerType:"direct"},o(this,u))).result}async signAmino(t,e){return(await p({method:"signAmino",params:[t,e],chainId:this.chainId,signerType:"amino"},o(this,u))).result}};u=new WeakMap,s(Y,"CosmiframeEitherSigner");var W=Y;var w;(function(n){n.IsCosmiframe="isCosmiframe",n.GetMetadata="getMetadata"})(w||(w={}));var m,F=class F{constructor(t){O(this,m,void 0);A(this,"p");if(!t.length)throw new Error("You must explicitly allow parent origins.");if(t.includes("*"))throw new Error("It is very unsafe to allow all origins because a controlling app has the power to manipulate messages before they are signed. If you really want to do this, pass in `UNSAFE_ALLOW_ANY_ORIGIN`.");v(this,m,t.includes(z)?["*"]:[...t]),this.p=new Proxy({getEnigmaUtils:e=>({getPubkey:()=>this.p.getEnigmaPubKey(e),decrypt:(...r)=>this.p.enigmaDecrypt(e,...r),encrypt:(...r)=>this.p.enigmaEncrypt(e,...r),getTxEncryptionKey:(...r)=>this.p.getEnigmaTxEncryptionKey(e,...r)})},{get:(e,r)=>r in e&&typeof e[r]!="function"?e[r]:(...c)=>r in e&&typeof e[r]=="function"?e[r](...c):this.callParentMethod({method:r.toString(),params:c}).then(({result:h})=>h)})}callParentMethod(t,e){return p(t,o(this,m),e)}async isReady(){if(!B())return!1;try{let{origin:t,result:e}=await this.callParentMethod({internal:!0,method:w.IsCosmiframe,params:[]},500);return t||e}catch(t){if(t instanceof x)return!1;throw t}}async getMetadata(){return(await this.callParentMethod({internal:!0,method:w.GetMetadata,params:[]},500)).result}getKeplrClient(){let t=new Proxy({version:"cosmiframe",mode:"extension",defaultOptions:{},getOfflineSigner:this.getOfflineSigner.bind(this),getOfflineSignerOnlyAmino:this.getOfflineSignerAmino.bind(this),getOfflineSignerAuto:e=>Promise.resolve(this.getOfflineSigner(e)),getEnigmaUtils:e=>({getPubkey:()=>t.getEnigmaPubKey(e),decrypt:(...r)=>t.enigmaDecrypt(e,...r),encrypt:(...r)=>t.enigmaEncrypt(e,...r),getTxEncryptionKey:(...r)=>t.getEnigmaTxEncryptionKey(e,...r)})},{get:(e,r)=>r in e&&typeof e[r]!="function"?e[r]:(...c)=>r in e&&typeof e[r]=="function"?e[r](...c):this.callParentMethod({method:r.toString(),params:c}).then(({result:h})=>h)});return t}getOfflineSigner(t){return new W(t,o(this,m))}getOfflineSignerAmino(t){return new D(t,o(this,m))}getOfflineSignerDirect(t){return new P(t,o(this,m))}static listen(t){let{iframe:e,target:r,getOfflineSignerDirect:c,getOfflineSignerAmino:h,nonSignerOverrides:I,signerOverrides:l,origins:d,metadata:_}=t,E=d?.length?d:["*"],k={[w.IsCosmiframe]:()=>!0,[w.GetMetadata]:()=>_||null},H=s(async({source:Q,origin:q,data:y})=>{if(!e.contentWindow)throw new Error("Iframe contentWindow does not exist.");if(Q!==e.contentWindow||!U(E,q)||!y||typeof y!="object"||!("id"in y)||!("method"in y)||!("params"in y))return;let{id:V,params:S,chainId:L,signType:X,internal:Z}=y,{method:i,signerType:N}=y;N||(N=X),i=i.replace(/^signer:/,"");let f;try{if(Z){if(typeof k[i]!="function")throw new Error(`Unknown internal method: ${i}`);f={type:"success",response:await k[i](...S)}}else if(N){if(!L)throw new Error("Missing chainId in signer message request");let a=typeof l=="function"?await l(L):l;if(a&&i in a){let g=K(await a[i](...S));g&&(f=g)}if(!f){let g=N==="direct"?await c(L):await h(L);if(!(i in g)||typeof g[i]!="function")throw new Error(`No ${N} signer method '${i}' for chain ID '${L}'.`);f={type:"success",response:await g[i](...S)}}}else{let a=typeof I=="function"?await I():I;if(a&&i in a){let g=K(await a[i](...S));g&&(f=g)}if(!f){if(!(i in r)||typeof r[i]!="function")throw new Error(`No method '${i}' on target.`);f={type:"success",response:await r[i](...S)}}}}catch(a){f={type:"error",error:a instanceof Error?a.message:`${a}`}}e.contentWindow?.postMessage({...f,id:V},q)},"listener");return window.addEventListener("message",H),()=>window.removeEventListener("message",H)}};m=new WeakMap,s(F,"Cosmiframe");var J=F;export{J as Cosmiframe};
//# sourceMappingURL=client.mjs.map