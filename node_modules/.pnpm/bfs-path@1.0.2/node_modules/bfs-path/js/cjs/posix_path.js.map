{"version":3,"file":"posix_path.js","sourceRoot":"","sources":["../../ts/posix_path.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Emulates Node's `path` module. This module contains utilities for handling and\n * transforming file paths. **All** of these methods perform only string\n * transformations. The file system is not consulted to check whether paths are\n * valid.\n * @see http://nodejs.org/api/path.html\n */\n\n// Type information only.\nimport * as _path from 'path';\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nconst splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nfunction posixSplitPath(filename: string): string[] {\n  var out = splitPathRe.exec(filename);\n  out.shift();\n  return out;\n}\n\n\n/**\n * Normalize a string path, taking care of '..' and '.' parts.\n *\n * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\n * @example Usage example\n *   path.normalize('/foo/bar//baz/asdf/quux/..')\n *   // returns\n *   '/foo/bar/baz/asdf'\n * @param [String] p The path to normalize.\n * @return [String]\n */\nexport function normalize(p: string): string {\n  // Special case: '' -> '.'\n  if (p === '') {\n    p = '.';\n  }\n  // It's very important to know if the path is relative or not, since it\n  // changes how we process .. and reconstruct the split string.\n  var absolute = p.charAt(0) === sep;\n  // Remove repeated //s\n  p = _removeDuplicateSeps(p);\n  // Try to remove as many '../' as possible, and remove '.' completely.\n  var components = p.split(sep);\n  var goodComponents: string[] = [];\n  for (var idx = 0; idx < components.length; idx++) {\n    var c = components[idx];\n    if (c === '.') {\n      continue;\n    } else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {\n      // In the absolute case: Path is relative to root, so we may pop even if\n      // goodComponents is empty (e.g. /../ => /)\n      // In the relative case: We're getting rid of a directory that preceded\n      // it (e.g. /foo/../bar -> /bar)\n      goodComponents.pop();\n    } else {\n      goodComponents.push(c);\n    }\n  }\n\n  // Add in '.' when it's a relative path with no other nonempty components.\n  // Possible results: '.' and './' (input: [''] or [])\n  // @todo Can probably simplify this logic.\n  if (!absolute && goodComponents.length < 2) {\n    switch (goodComponents.length) {\n      case 1:\n        if (goodComponents[0] === '') {\n          goodComponents.unshift('.');\n        }\n        break;\n      default:\n        goodComponents.push('.');\n    }\n  }\n  p = goodComponents.join(sep);\n  if (absolute && p.charAt(0) !== sep) {\n    p = sep + p;\n  }\n  return p;\n}\n\n/**\n * Join all arguments together and normalize the resulting path.\n *\n * Arguments must be strings.\n * @example Usage\n *   path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')\n *   // returns\n *   '/foo/bar/baz/asdf'\n *\n *   path.join('foo', {}, 'bar')\n *   // throws exception\n *   TypeError: Arguments to path.join must be strings\n * @param [String,...] paths Each component of the path\n * @return [String]\n */\nexport function join(...paths: any[]): string {\n  // Required: Prune any non-strings from the path. I also prune empty segments\n  // so we can do a simple join of the array.\n  var processed: string[] = [];\n  for (var i = 0; i < paths.length; i++) {\n    var segment = paths[i];\n    if (typeof segment !== 'string') {\n      throw new TypeError(\"Invalid argument type to path.join: \" + (typeof segment));\n    } else if (segment !== '') {\n      processed.push(segment);\n    }\n  }\n  return normalize(processed.join(sep));\n}\n\n/**\n * Resolves to to an absolute path.\n *\n * If to isn't already absolute from arguments are prepended in right to left\n * order, until an absolute path is found. If after using all from paths still\n * no absolute path is found, the current working directory is used as well.\n * The resulting path is normalized, and trailing slashes are removed unless\n * the path gets resolved to the root directory. Non-string arguments are\n * ignored.\n *\n * Another way to think of it is as a sequence of cd commands in a shell.\n *\n *     path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')\n *\n * Is similar to:\n *\n *     cd foo/bar\n *     cd /tmp/file/\n *     cd ..\n *     cd a/../subfile\n *     pwd\n *\n * The difference is that the different paths don't need to exist and may also\n * be files.\n * @example Usage example\n *   path.resolve('/foo/bar', './baz')\n *   // returns\n *   '/foo/bar/baz'\n *\n *   path.resolve('/foo/bar', '/tmp/file/')\n *   // returns\n *   '/tmp/file'\n *\n *   path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')\n *   // if currently in /home/myself/node, it returns\n *   '/home/myself/node/wwwroot/static_files/gif/image.gif'\n * @param [String,...] paths\n * @return [String]\n */\nexport function resolve(...paths: string[]): string {\n  // Monitor for invalid paths, throw out empty paths, and look for the *last*\n  // absolute path that we see.\n  var processed: string[] = [];\n  for (var i = 0; i < paths.length; i++) {\n    var p = paths[i];\n    if (typeof p !== 'string') {\n      throw new TypeError(\"Invalid argument type to path.join: \" + (typeof p));\n    } else if (p !== '') {\n      // Remove anything that has occurred before this absolute path, as it\n      // doesn't matter.\n      if (p.charAt(0) === sep) {\n        processed = [];\n      }\n      processed.push(p);\n    }\n  }\n  // Special: Remove trailing slash unless it's the root\n  var resolved = normalize(processed.join(sep));\n  if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === sep) {\n    return resolved.substr(0, resolved.length - 1);\n  }\n  // Special: If it doesn't start with '/', it's relative and we need to append\n  // the current directory.\n  if (resolved.charAt(0) !== sep) {\n    // Remove ./, since we're going to append the current directory.\n    if (resolved.charAt(0) === '.' && (resolved.length === 1 || resolved.charAt(1) === sep)) {\n      resolved = resolved.length === 1 ? '' : resolved.substr(2);\n    }\n    // Append the current directory, which *must* be an absolute path.\n    var cwd = process.cwd();\n    if (resolved !== '') {\n      // cwd will never end in a /... unless it's the root.\n      resolved = normalize(cwd + (cwd !== '/' ? sep : '') + resolved);\n    } else {\n      resolved = cwd;\n    }\n  }\n  return resolved;\n}\n\n/**\n * Solve the relative path from from to to.\n *\n * At times we have two absolute paths, and we need to derive the relative path\n * from one to the other. This is actually the reverse transform of\n * path.resolve, which means we see that:\n *\n *    path.resolve(from, path.relative(from, to)) == path.resolve(to)\n *\n * @example Usage example\n *   path.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')\n *   // returns\n *   '..\\\\..\\\\impl\\\\bbb'\n *\n *   path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\n *   // returns\n *   '../../impl/bbb'\n * @param [String] from\n * @param [String] to\n * @return [String]\n */\nexport function relative(from: string, to: string): string {\n  var i: number;\n  // Alright. Let's resolve these two to absolute paths and remove any\n  // weirdness.\n  from = resolve(from);\n  to = resolve(to);\n  var fromSegs = from.split(sep);\n  var toSegs = to.split(sep);\n  // Remove the first segment on both, as it's '' (both are absolute paths)\n  toSegs.shift();\n  fromSegs.shift();\n  // There are two segments to this path:\n  // * Going *up* the directory hierarchy with '..'\n  // * Going *down* the directory hierarchy with foo/baz/bat.\n  var upCount = 0;\n  var downSegs: string[] = [];\n  // Figure out how many things in 'from' are shared with 'to'.\n  for (i = 0; i < fromSegs.length; i++) {\n    var seg = fromSegs[i];\n    if (seg === toSegs[i]) {\n      continue;\n    }\n    // The rest of 'from', including the current element, indicates how many\n    // directories we need to go up.\n    upCount = fromSegs.length - i;\n    break;\n  }\n  // The rest of 'to' indicates where we need to change to. We place this\n  // outside of the loop, as toSegs.length may be greater than fromSegs.length.\n  downSegs = toSegs.slice(i);\n  // Special case: If 'from' is '/'\n  if (fromSegs.length === 1 && fromSegs[0] === '') {\n    upCount = 0;\n  }\n  // upCount can't be greater than the number of fromSegs\n  // (cd .. from / is still /)\n  if (upCount > fromSegs.length) {\n    upCount = fromSegs.length;\n  }\n  // Create the final string!\n  var rv = '';\n  for (i = 0; i < upCount; i++) {\n    rv += '../';\n  }\n  rv += downSegs.join(sep);\n  // Special case: Remove trailing '/'. Happens if it's all up and no down.\n  if (rv.length > 1 && rv.charAt(rv.length - 1) === sep) {\n    rv = rv.substr(0, rv.length - 1);\n  }\n  return rv;\n}\n\n/**\n * Return the directory name of a path. Similar to the Unix `dirname` command.\n *\n * Note that BrowserFS does not validate if the path is actually a valid\n * directory.\n * @example Usage example\n *   path.dirname('/foo/bar/baz/asdf/quux')\n *   // returns\n *   '/foo/bar/baz/asdf'\n * @param [String] p The path to get the directory name of.\n * @return [String]\n */\nexport function dirname(p: string): string {\n  // We get rid of //, but we don't modify anything else (e.g. any extraneous .\n  // and ../ are kept intact)\n  p = _removeDuplicateSeps(p);\n  var absolute = p.charAt(0) === sep;\n  var sections = p.split(sep);\n  // Do 1 if it's /foo/bar, 2 if it's /foo/bar/\n  if (sections.pop() === '' && sections.length > 0) {\n    sections.pop();\n  }\n  // # of sections needs to be > 1 if absolute, since the first section is '' for '/'.\n  // If not absolute, the first section is the first part of the path, and is OK\n  // to return.\n  if (sections.length > 1 || (sections.length === 1 && !absolute)) {\n    return sections.join(sep);\n  } else if (absolute) {\n    return sep;\n  } else {\n    return '.';\n  }\n}\n\n/**\n * Return the last portion of a path. Similar to the Unix basename command.\n * @example Usage example\n *   path.basename('/foo/bar/baz/asdf/quux.html')\n *   // returns\n *   'quux.html'\n *\n *   path.basename('/foo/bar/baz/asdf/quux.html', '.html')\n *   // returns\n *   'quux'\n * @param [String] p\n * @param [String?] ext\n * @return [String]\n */\nexport function basename(p: string, ext: string = \"\"): string {\n  // Special case: Normalize will modify this to '.'\n  if (p === '') {\n    return p;\n  }\n  // Normalize the string first to remove any weirdness.\n  p = normalize(p);\n  // Get the last part of the string.\n  var sections = p.split(sep);\n  var lastPart = sections[sections.length - 1];\n  // Special case: If it's empty, then we have a string like so: foo/\n  // Meaning, 'foo' is guaranteed to be a directory.\n  if (lastPart === '' && sections.length > 1) {\n    return sections[sections.length - 2];\n  }\n  // Remove the extension, if need be.\n  if (ext.length > 0) {\n    var lastPartExt = lastPart.substr(lastPart.length - ext.length);\n    if (lastPartExt === ext) {\n      return lastPart.substr(0, lastPart.length - ext.length);\n    }\n  }\n  return lastPart;\n}\n\n/**\n * Return the extension of the path, from the last '.' to end of string in the\n * last portion of the path. If there is no '.' in the last portion of the path\n * or the first character of it is '.', then it returns an empty string.\n * @example Usage example\n *   path.extname('index.html')\n *   // returns\n *   '.html'\n *\n *   path.extname('index.')\n *   // returns\n *   '.'\n *\n *   path.extname('index')\n *   // returns\n *   ''\n * @param [String] p\n * @return [String]\n */\nexport function extname(p: string): string {\n  p = normalize(p);\n  var sections = p.split(sep);\n  p = sections.pop();\n  // Special case: foo/file.ext/ should return '.ext'\n  if (p === '' && sections.length > 0) {\n    p = sections.pop();\n  }\n  if (p === '..') {\n    return '';\n  }\n  var i = p.lastIndexOf('.');\n  if (i === -1 || i === 0) {\n    return '';\n  }\n  return p.substr(i);\n}\n\n/**\n * Checks if the given path is an absolute path.\n *\n * Despite not being documented, this is a tested part of Node's path API.\n * @param [String] p\n * @return [Boolean] True if the path appears to be an absolute path.\n */\nexport function isAbsolute(p: string): boolean {\n  return p.length > 0 && p.charAt(0) === sep;\n}\n\n/**\n * Unknown. Undocumented.\n */\nexport function _makeLong(p: string): string {\n  return p;\n}\n\n/**\n * Returns an object from a path string.\n */\nexport function parse(p: string): _path.ParsedPath {\n  var allParts = posixSplitPath(p);\n  return {\n    root: allParts[0],\n    dir: allParts[0] + allParts[1].slice(0, -1),\n    base: allParts[2],\n    ext: allParts[3],\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n  };\n}\n\nexport function format(pathObject: _path.ParsedPath): string {\n  if (pathObject === null || typeof pathObject !== 'object') {\n    throw new TypeError(`Parameter 'pathObject' must be an object, not ${typeof pathObject}`);\n  }\n\n  var root = pathObject.root || '';\n\n  if (typeof root !== 'string') {\n    throw new TypeError(\n        \"'pathObject.root' must be a string or undefined, not \" +\n        typeof pathObject.root\n    );\n  }\n\n  var dir = pathObject.dir ? pathObject.dir + sep : '';\n  var base = pathObject.base || '';\n  return dir + base;\n}\n\n// The platform-specific file separator. BrowserFS uses `/`.\nexport const sep: string = '/';\n\nexport const _replaceRegex = new RegExp(\"//+\", 'g');\n\nexport function _removeDuplicateSeps(p: string): string {\n  p = p.replace(_replaceRegex, sep);\n  return p;\n}\n\n// The platform-specific path delimiter. BrowserFS uses `:`.\nexport const delimiter = ':';\n"]}