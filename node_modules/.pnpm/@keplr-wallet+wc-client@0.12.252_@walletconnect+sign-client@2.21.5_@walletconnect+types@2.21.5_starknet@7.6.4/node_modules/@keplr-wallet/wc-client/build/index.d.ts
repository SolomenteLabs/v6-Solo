/// <reference types="node" />
import { AminoSignResponse, BroadcastMode, ChainInfo, ChainInfoWithoutEndpoints, DirectAuxSignResponse, DirectSignResponse, EthSignType, ICNSAdr36Signatures, IEthereumProvider, Keplr, KeplrIntereactionOptions, KeplrMode, KeplrSignOptions, Key, OfflineAminoSigner, OfflineDirectSigner, SecretUtils, SettledResponses, SignPsbtOptions, StdSignature, StdSignDoc, SupportedPaymentType } from "@keplr-wallet/types";
import SignClient from "@walletconnect/sign-client";
import { ProposalTypes, SessionTypes } from "@walletconnect/types";
import Long from "long";
import EventEmitter from "events";
import { Call, DeployAccountSignerDetails, InvocationsSignerDetails } from "starknet";
interface RequestParams {
    topic: string;
    request: {
        method: string;
        params: any;
    };
    chainId: string;
    expiry?: number;
}
interface KeplrGetKeyWalletConnectV2Response {
    readonly name: string;
    readonly algo: string;
    readonly pubKey: string;
    readonly address: string;
    readonly bech32Address: string;
    readonly ethereumHexAddress: string;
    readonly isNanoLedger: boolean;
}
export declare class KeplrWalletConnectV2 implements Keplr {
    readonly signClient: SignClient;
    readonly options: {
        sendTx?: Keplr["sendTx"];
        sessionProperties?: ProposalTypes.SessionProperties;
    };
    defaultOptions: KeplrIntereactionOptions;
    readonly version: string;
    readonly mode: KeplrMode;
    protected readonly storeKey = "keplr_wallet_connect_v2_key";
    protected readonly storeSuggestChainKey = "keplr_wallet_connect_v2_suggest_chain_key";
    protected readonly storeSuggestTokenKey = "keplr_wallet_connect_v2_suggest_token_key";
    constructor(signClient: SignClient, options: {
        sendTx?: Keplr["sendTx"];
        sessionProperties?: ProposalTypes.SessionProperties;
    });
    protected saveKeys(sessionProperty: ProposalTypes.SessionProperties): void;
    protected convertToKeplrGetKeyWalletConnectV2Response(data: any): KeplrGetKeyWalletConnectV2Response;
    protected getLastSession(): SessionTypes.Struct | undefined;
    protected getCurrentTopic(): string;
    protected getKeyLastSeenKey(): string;
    protected getLastSeenKey(chainId: string): KeplrGetKeyWalletConnectV2Response | undefined;
    protected getAllLastSeenKey(): any;
    protected saveLastSeenKey(chainId: string, response: KeplrGetKeyWalletConnectV2Response): void;
    protected saveAllLastSeenKey(data: {
        [chainId: string]: KeplrGetKeyWalletConnectV2Response | undefined;
    }): void;
    protected getSuggestChainKey(): string;
    protected getRegisteredSuggestChain(chainId: string): ChainInfo | undefined;
    protected getAllRegisteredSuggestChain(): any;
    protected saveRegisteredSuggestChain(chainInfo: ChainInfo): void;
    protected saveAllRegisteredSuggestChain(data: {
        [chainId: string]: ChainInfo | undefined;
    }): void;
    protected getSuggestTokenKey(): string;
    protected getRegisteredSuggestToken(contractAddress: string): ChainInfo | undefined;
    protected getAllRegisteredSuggestToken(): any;
    protected saveRegisteredSuggestToken(chainId: string, contractAddress: string, viewingKey?: string): void;
    protected saveAllRegisteredSuggestToken(data: {
        [contractAddress: string]: {
            chainId: string;
            contractAddress: string;
            viewingKey?: string;
        } | undefined;
    }): void;
    protected sendCustomRequest<T>(requestParams: RequestParams): Promise<T>;
    protected getNamespaceChainId(): string;
    protected checkDeepLink(): void;
    ping(): Promise<void>;
    changeKeyRingName(_opts: {
        defaultName: string;
        editable?: boolean | undefined;
    }): Promise<string>;
    disable(_chainIds?: string | string[]): Promise<void>;
    enable(chainIds: string | string[]): Promise<void>;
    enigmaDecrypt(_chainId: string, _ciphertext: Uint8Array, _nonce: Uint8Array): Promise<Uint8Array>;
    enigmaEncrypt(_chainId: string, _contractCodeHash: string, _msg: object): Promise<Uint8Array>;
    experimentalSignEIP712CosmosTx_v0(_chainId: string, _signer: string, _eip712: {
        types: Record<string, {
            name: string;
            type: string;
        }[] | undefined>;
        domain: Record<string, any>;
        primaryType: string;
    }, _signDoc: StdSignDoc, _signOptions?: KeplrSignOptions): Promise<AminoSignResponse>;
    experimentalSuggestChain(_chainInfo: ChainInfo): Promise<void>;
    getChainInfosWithoutEndpoints(): Promise<ChainInfoWithoutEndpoints[]>;
    getChainInfoWithoutEndpoints(_chainId: string): Promise<ChainInfoWithoutEndpoints>;
    getEnigmaPubKey(_chainId: string): Promise<Uint8Array>;
    getEnigmaTxEncryptionKey(_chainId: string, _nonce: Uint8Array): Promise<Uint8Array>;
    getEnigmaUtils(_chainId: string): SecretUtils;
    getKey(chainId: string): Promise<Key>;
    getKeysSettled(chainIds: string[]): Promise<SettledResponses<Key>>;
    getOfflineSigner(chainId: string, signOptions?: KeplrSignOptions): OfflineAminoSigner & OfflineDirectSigner;
    getOfflineSignerAuto(chainId: string, signOptions?: KeplrSignOptions): Promise<OfflineAminoSigner | OfflineDirectSigner>;
    getOfflineSignerOnlyAmino(chainId: string, signOptions?: KeplrSignOptions): OfflineAminoSigner;
    getSecret20ViewingKey(_chainId: string, _contractAddress: string): Promise<string>;
    sendTx(chainId: string, tx: Uint8Array, mode: BroadcastMode): Promise<Uint8Array>;
    signAmino(chainId: string, signer: string, signDoc: StdSignDoc, signOptions?: KeplrSignOptions): Promise<AminoSignResponse>;
    signArbitrary(chainId: string, signer: string, data: string | Uint8Array): Promise<StdSignature>;
    signDirect(chainId: string, signer: string, signDoc: {
        bodyBytes?: Uint8Array | null;
        authInfoBytes?: Uint8Array | null;
        chainId?: string | null;
        accountNumber?: Long | null;
    }, signOptions?: KeplrSignOptions): Promise<DirectSignResponse>;
    signDirectAux(_chainId: string, _signer: string, _signDoc: {
        bodyBytes?: Uint8Array | null;
        publicKey?: {
            typeUrl: string;
            value: Uint8Array;
        } | null;
        chainId?: string | null;
        accountNumber?: Long | null;
        sequence?: Long | null;
        tip?: {
            amount: {
                denom: string;
                amount: string;
            }[];
            tipper: string;
        } | null;
    }, _signOptions?: Exclude<KeplrSignOptions, "preferNoSetFee" | "disableBalanceCheck">): Promise<DirectAuxSignResponse>;
    signEthereum(chainId: string, signer: string, data: string | Uint8Array, type: EthSignType): Promise<Uint8Array>;
    signICNSAdr36(_chainId: string, _contractAddress: string, _owner: string, _username: string, _addressChainIds: string[]): Promise<ICNSAdr36Signatures>;
    suggestToken(_chainId: string, _contractAddress: string, _viewingKey?: string): Promise<void>;
    verifyArbitrary(_chainId: string, _signer: string, _data: string | Uint8Array, _signature: StdSignature): Promise<boolean>;
    sendEthereumTx(_chainId: string, _tx: Uint8Array): Promise<string>;
    suggestERC20(_chainId: string, _contractAddress: string): Promise<void>;
    getStarknetKey(_chainId: string): Promise<{
        name: string;
        hexAddress: string;
        pubKey: Uint8Array;
        address: Uint8Array;
        isNanoLedger: boolean;
    }>;
    getStarknetKeysSettled(_chainIds: string[]): Promise<SettledResponses<{
        name: string;
        hexAddress: string;
        pubKey: Uint8Array;
        address: Uint8Array;
        isNanoLedger: boolean;
    }>>;
    signStarknetTx(): Promise<{
        transactions: Call[];
        details: InvocationsSignerDetails;
        signature: string[];
    }>;
    signStarknetDeployAccountTransaction(_chainId: string, _transaction: DeployAccountSignerDetails): Promise<{
        transaction: DeployAccountSignerDetails;
        signature: string[];
    }>;
    getBitcoinKey(_chainId: string): Promise<{
        name: string;
        pubKey: Uint8Array;
        address: string;
        paymentType: SupportedPaymentType;
        isNanoLedger: boolean;
    }>;
    getBitcoinKeysSettled(_chainIds: string[]): Promise<SettledResponses<{
        name: string;
        pubKey: Uint8Array;
        address: string;
        paymentType: SupportedPaymentType;
        isNanoLedger: boolean;
    }>>;
    signPsbt(_chainId: string, _psbtHex: string, _options?: SignPsbtOptions): Promise<string>;
    signPsbts(_chainId: string, _psbtsHexes: string[], _options?: SignPsbtOptions): Promise<string[]>;
    readonly ethereum: MockEthereumProvider;
    readonly starknet: any;
    readonly bitcoin: any;
}
declare class MockEthereumProvider extends EventEmitter implements IEthereumProvider {
    readonly chainId: string | null;
    readonly selectedAddress: string | null;
    readonly networkVersion: string | null;
    readonly isKeplr: boolean;
    readonly isMetaMask: boolean;
    constructor();
    isConnected(): boolean;
    request<T>({}: {
        method: string;
        params?: unknown[] | Record<string, unknown>;
    }): Promise<T>;
    enable(): Promise<string[]>;
    net_version(): Promise<string>;
}
export {};
