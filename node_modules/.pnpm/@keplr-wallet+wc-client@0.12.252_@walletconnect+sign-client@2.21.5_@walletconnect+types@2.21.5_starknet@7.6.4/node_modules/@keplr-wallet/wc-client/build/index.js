"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeplrWalletConnectV2 = void 0;
const provider_1 = require("@keplr-wallet/provider");
const buffer_1 = require("buffer/");
const long_1 = __importDefault(require("long"));
const events_1 = __importDefault(require("events"));
class KeplrWalletConnectV2 {
    constructor(signClient, options) {
        this.signClient = signClient;
        this.options = options;
        this.defaultOptions = {};
        this.version = "0.12.20";
        this.mode = "walletconnect";
        this.storeKey = "keplr_wallet_connect_v2_key";
        this.storeSuggestChainKey = "keplr_wallet_connect_v2_suggest_chain_key";
        this.storeSuggestTokenKey = "keplr_wallet_connect_v2_suggest_token_key";
        this.ethereum = new MockEthereumProvider();
        // TODO: 이거 마지막에 꼭 구현해야한다.
        //       일단은 다른게 더 급해서 일단 any로 처리
        this.starknet = {};
        // TODO: 이거 마지막에 꼭 구현해야한다.
        //       일단은 다른게 더 급해서 일단 any로 처리
        this.bitcoin = {};
        if (options.sessionProperties) {
            this.saveKeys(options.sessionProperties);
        }
        signClient.on("session_event", (event) => {
            if (event.params.event.name === "keplr_accountsChanged") {
                this.saveKeys(event.params.event.data);
                window.dispatchEvent(new Event("keplr_keystorechange"));
            }
        });
        signClient.on("session_delete", () => __awaiter(this, void 0, void 0, function* () {
            localStorage.removeItem(this.getKeyLastSeenKey());
            localStorage.removeItem(this.getSuggestChainKey());
            localStorage.removeItem(this.getSuggestTokenKey());
        }));
    }
    saveKeys(sessionProperty) {
        if (sessionProperty.hasOwnProperty("keys")) {
            const keys = JSON.parse(sessionProperty["keys"]);
            if (keys.length > 0) {
                keys.forEach((key) => {
                    if (key.hasOwnProperty("chainId")) {
                        this.saveLastSeenKey(key["chainId"], this.convertToKeplrGetKeyWalletConnectV2Response(key));
                    }
                });
            }
        }
    }
    convertToKeplrGetKeyWalletConnectV2Response(data) {
        if (!data.hasOwnProperty("name") ||
            !data.hasOwnProperty("algo") ||
            !data.hasOwnProperty("pubKey") ||
            !data.hasOwnProperty("address") ||
            !data.hasOwnProperty("bech32Address") ||
            !data.hasOwnProperty("ethereumHexAddress") ||
            !data.hasOwnProperty("isNanoLedger")) {
            throw new Error("Invalid data");
        }
        return {
            name: data.name,
            algo: data.algo,
            pubKey: data.pubKey,
            address: data.address,
            bech32Address: data.bech32Address,
            ethereumHexAddress: data.ethereumHexAddress,
            isNanoLedger: data.isNanoLedger === "true",
        };
    }
    getLastSession() {
        const lastKeyIndex = this.signClient.session.getAll().length - 1;
        return this.signClient.session.getAll()[lastKeyIndex];
    }
    getCurrentTopic() {
        const lastSession = this.getLastSession();
        if (!lastSession) {
            throw new Error("No session");
        }
        return lastSession.topic;
    }
    getKeyLastSeenKey() {
        const topic = this.getCurrentTopic();
        return `${this.storeKey}/${topic}-key`;
    }
    getLastSeenKey(chainId) {
        const saved = this.getAllLastSeenKey();
        if (!saved) {
            return undefined;
        }
        return saved[chainId];
    }
    getAllLastSeenKey() {
        const data = localStorage.getItem(this.getKeyLastSeenKey());
        if (!data) {
            return undefined;
        }
        return JSON.parse(data);
    }
    saveLastSeenKey(chainId, response) {
        let saved = this.getAllLastSeenKey();
        if (!saved) {
            saved = {};
        }
        saved[chainId] = response;
        this.saveAllLastSeenKey(saved);
    }
    saveAllLastSeenKey(data) {
        localStorage.setItem(this.getKeyLastSeenKey(), JSON.stringify(data));
    }
    getSuggestChainKey() {
        const topic = this.getCurrentTopic();
        return `${this.storeSuggestChainKey}/${topic}-key`;
    }
    getRegisteredSuggestChain(chainId) {
        const saved = this.getAllRegisteredSuggestChain();
        if (!saved) {
            return undefined;
        }
        return saved[chainId];
    }
    getAllRegisteredSuggestChain() {
        const data = localStorage.getItem(this.getSuggestChainKey());
        if (!data) {
            return undefined;
        }
        return JSON.parse(data);
    }
    saveRegisteredSuggestChain(chainInfo) {
        let saved = this.getAllRegisteredSuggestChain();
        if (!saved) {
            saved = {};
        }
        saved[chainInfo.chainId] = chainInfo;
        this.saveAllRegisteredSuggestChain(saved);
    }
    saveAllRegisteredSuggestChain(data) {
        localStorage.setItem(this.getSuggestChainKey(), JSON.stringify(data));
    }
    getSuggestTokenKey() {
        const topic = this.getCurrentTopic();
        return `${this.storeSuggestTokenKey}/${topic}-key`;
    }
    getRegisteredSuggestToken(contractAddress) {
        const saved = this.getAllRegisteredSuggestToken();
        if (!saved) {
            return undefined;
        }
        return saved[contractAddress];
    }
    getAllRegisteredSuggestToken() {
        const data = localStorage.getItem(this.getSuggestTokenKey());
        if (!data) {
            return undefined;
        }
        return JSON.parse(data);
    }
    saveRegisteredSuggestToken(chainId, contractAddress, viewingKey) {
        let saved = this.getAllRegisteredSuggestToken();
        if (!saved) {
            saved = {};
        }
        saved[contractAddress] = {
            chainId,
            contractAddress,
            viewingKey,
        };
        this.saveAllRegisteredSuggestToken(saved);
    }
    saveAllRegisteredSuggestToken(data) {
        localStorage.setItem(this.getSuggestTokenKey(), JSON.stringify(data));
    }
    sendCustomRequest(requestParams) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.signClient.request(requestParams);
            return response;
        });
    }
    getNamespaceChainId() {
        const lastSession = this.getLastSession();
        if (lastSession &&
            lastSession.namespaces.hasOwnProperty("cosmos") &&
            lastSession.namespaces["cosmos"].hasOwnProperty("accounts")) {
            const splitAccount = lastSession.namespaces["cosmos"]["accounts"][0].split(":");
            return `${splitAccount[0]}:${splitAccount[1]}`;
        }
        return "cosmos:cosmoshub-4";
    }
    checkDeepLink() {
        const mobileLinkInfo = localStorage.getItem("wallet-connect-v2-mobile-link");
        if (mobileLinkInfo) {
            window.location.href = JSON.parse(mobileLinkInfo).href;
        }
    }
    ping() {
        return Promise.resolve();
    }
    changeKeyRingName(_opts) {
        throw new Error("Not yet implemented");
    }
    disable(_chainIds) {
        throw new Error("Not yet implemented");
    }
    enable(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof chainIds === "string") {
                chainIds = [chainIds];
            }
            // Check public key from local storage.
            const keys = yield this.getAllLastSeenKey();
            if (keys) {
                const hasChainId = chainIds.every((chainId) => {
                    return Object.keys(keys).includes(chainId);
                });
                if (hasChainId) {
                    return;
                }
            }
            this.checkDeepLink();
            // Request enable from the mobile wallet.
            const topic = this.getCurrentTopic();
            const chainId = this.getNamespaceChainId();
            if (!chainId) {
                throw new Error("No Namespace chain id");
            }
            const param = {
                topic: topic,
                chainId: this.getNamespaceChainId(),
                request: {
                    method: "keplr_enable",
                    params: {
                        chainId: chainIds,
                    },
                },
            };
            yield this.sendCustomRequest(param);
            // session의 정보가 업데이트 되기 전에 다음로직이 실행되면 안되기 때문에 namespace가 업데이트 될때까지 기다린다.
            // We wait for the namespace to be updated because we don't want the next logic to run before the session's information is updated.
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                while (true) {
                    yield new Promise((resolve) => setTimeout(resolve, 100));
                    const lastSession = this.getLastSession();
                    if (lastSession &&
                        lastSession.namespaces.hasOwnProperty("cosmos") &&
                        lastSession.namespaces["cosmos"].hasOwnProperty("accounts")) {
                        const hasChainId = lastSession.namespaces["cosmos"]["accounts"].some((account) => {
                            const chainId = account.replace("cosmos:", "").split(":")[0];
                            return chainIds.includes(chainId);
                        });
                        if (hasChainId) {
                            resolve();
                            return;
                        }
                    }
                }
            }));
        });
    }
    enigmaDecrypt(_chainId, _ciphertext, _nonce) {
        throw new Error("Not yet implemented");
    }
    enigmaEncrypt(_chainId, _contractCodeHash, 
    // eslint-disable-next-line @typescript-eslint/ban-types
    _msg) {
        throw new Error("Not yet implemented");
    }
    experimentalSignEIP712CosmosTx_v0(_chainId, _signer, _eip712, _signDoc, _signOptions = {}) {
        throw new Error("Not yet implemented");
    }
    experimentalSuggestChain(_chainInfo) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (((_a = _chainInfo.features) === null || _a === void 0 ? void 0 : _a.includes("stargate")) ||
                ((_b = _chainInfo.features) === null || _b === void 0 ? void 0 : _b.includes("no-legacy-stdTx"))) {
                console.warn("“stargate”, “no-legacy-stdTx” feature has been deprecated. The launchpad is no longer supported, thus works without the two features. We would keep the aforementioned two feature for a while, but the upcoming update would potentially cause errors. Remove the two feature.");
            }
            const registeredChainInfo = this.getRegisteredSuggestChain(_chainInfo.chainId);
            if (registeredChainInfo) {
                return;
            }
            this.checkDeepLink();
            const topic = this.getCurrentTopic();
            const param = {
                topic,
                chainId: this.getNamespaceChainId(),
                request: {
                    method: "keplr_experimentalSuggestChain",
                    params: {
                        chainInfo: _chainInfo,
                    },
                },
            };
            yield this.sendCustomRequest(param);
            this.saveRegisteredSuggestChain(_chainInfo);
        });
    }
    getChainInfosWithoutEndpoints() {
        throw new Error("Not yet implemented");
    }
    getChainInfoWithoutEndpoints(_chainId) {
        throw new Error("Not yet implemented");
    }
    getEnigmaPubKey(_chainId) {
        throw new Error("Not yet implemented");
    }
    getEnigmaTxEncryptionKey(_chainId, _nonce) {
        throw new Error("Not yet implemented");
    }
    getEnigmaUtils(_chainId) {
        throw new Error("Not yet implemented");
    }
    getKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            // Check public key from local storage.
            const lastSeenKey = this.getLastSeenKey(chainId);
            if (lastSeenKey) {
                return {
                    algo: lastSeenKey.algo,
                    bech32Address: lastSeenKey.bech32Address,
                    ethereumHexAddress: lastSeenKey.ethereumHexAddress,
                    address: buffer_1.Buffer.from(lastSeenKey.address, "base64"),
                    name: lastSeenKey.name,
                    pubKey: buffer_1.Buffer.from(lastSeenKey.pubKey, "base64"),
                    isNanoLedger: lastSeenKey.isNanoLedger,
                    isKeystone: false,
                };
            }
            // Check public key from session properties.
            const lastSession = this.getLastSession();
            if (lastSession && lastSession.sessionProperties) {
                const sessionChainId = lastSession.sessionProperties["chainId"];
                if (sessionChainId === chainId) {
                    return {
                        algo: lastSession.sessionProperties["algo"],
                        bech32Address: lastSession.sessionProperties["bech32Address"],
                        ethereumHexAddress: lastSession.sessionProperties["ethereumHexAddress"],
                        address: buffer_1.Buffer.from(lastSession.sessionProperties["address"], "base64"),
                        name: lastSession.sessionProperties["name"],
                        pubKey: buffer_1.Buffer.from(lastSession.sessionProperties["pubKey"], "base64"),
                        isNanoLedger: lastSession.sessionProperties["isNanoLedger"] === "true",
                        isKeystone: false,
                    };
                }
            }
            // Request `get_key` from the mobile wallet.
            const topic = this.getCurrentTopic();
            const param = {
                topic,
                chainId: this.getNamespaceChainId(),
                request: {
                    method: "keplr_getKey",
                    params: {
                        chainId,
                    },
                },
            };
            const response = yield this.sendCustomRequest(param);
            return Object.assign(Object.assign({}, response), { pubKey: buffer_1.Buffer.from(response.pubKey, "base64"), address: buffer_1.Buffer.from(response.address, "base64"), isKeystone: false });
        });
    }
    getKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const paramArray = chainIds.map((chainId) => __awaiter(this, void 0, void 0, function* () {
                return yield this.getKey(chainId);
            }));
            return yield Promise.allSettled(paramArray);
        });
    }
    getOfflineSigner(chainId, signOptions) {
        return new provider_1.CosmJSOfflineSigner(chainId, this, signOptions);
    }
    getOfflineSignerAuto(chainId, signOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield this.getKey(chainId);
            if (key.isNanoLedger) {
                return new provider_1.CosmJSOfflineSignerOnlyAmino(chainId, this, signOptions);
            }
            return new provider_1.CosmJSOfflineSigner(chainId, this, signOptions);
        });
    }
    getOfflineSignerOnlyAmino(chainId, signOptions) {
        return new provider_1.CosmJSOfflineSignerOnlyAmino(chainId, this, signOptions);
    }
    getSecret20ViewingKey(_chainId, _contractAddress) {
        throw new Error("Not yet implemented");
    }
    sendTx(chainId, tx, mode) {
        if (this.options.sendTx) {
            return this.options.sendTx(chainId, tx, mode);
        }
        throw new Error("send tx is not delivered by options");
    }
    signAmino(chainId, signer, signDoc, signOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkDeepLink();
            const topic = this.getCurrentTopic();
            const param = {
                topic,
                chainId: this.getNamespaceChainId(),
                request: {
                    method: "keplr_signAmino",
                    params: {
                        chainId,
                        signer,
                        signDoc,
                        signOptions: signOptions,
                    },
                },
            };
            return yield this.sendCustomRequest(param);
        });
    }
    signArbitrary(chainId, signer, data) {
        this.checkDeepLink();
        const topic = this.getCurrentTopic();
        const param = {
            topic,
            chainId: this.getNamespaceChainId(),
            request: {
                method: "keplr_signArbitrary",
                params: {
                    chainId,
                    signer,
                    type: typeof data === "string" ? "string" : "Uint8Array",
                    data: typeof data === "string"
                        ? data
                        : buffer_1.Buffer.from(data).toString("base64"),
                },
            },
        };
        return this.sendCustomRequest(param);
    }
    signDirect(chainId, signer, signDoc, signOptions) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.checkDeepLink();
            const topic = this.getCurrentTopic();
            const param = {
                topic,
                chainId: this.getNamespaceChainId(),
                request: {
                    method: "keplr_signDirect",
                    params: {
                        chainId,
                        signer,
                        signDoc: {
                            chainId: signDoc.chainId,
                            accountNumber: (_a = signDoc.accountNumber) === null || _a === void 0 ? void 0 : _a.toString(),
                            bodyBytes: signDoc.bodyBytes
                                ? buffer_1.Buffer.from(signDoc.bodyBytes).toString("base64")
                                : null,
                            authInfoBytes: signDoc.authInfoBytes
                                ? buffer_1.Buffer.from(signDoc.authInfoBytes).toString("base64")
                                : null,
                        },
                        signOptions: signOptions,
                    },
                },
            };
            const response = yield this.sendCustomRequest(param);
            return {
                signature: response.signature,
                signed: {
                    chainId: (_b = response.signed.chainId) !== null && _b !== void 0 ? _b : "",
                    accountNumber: response.signed.accountNumber
                        ? long_1.default.fromString(response.signed.accountNumber)
                        : new long_1.default(0),
                    bodyBytes: response.signed.bodyBytes
                        ? buffer_1.Buffer.from(response.signed.bodyBytes, "base64")
                        : new Uint8Array([]),
                    authInfoBytes: response.signed.authInfoBytes
                        ? buffer_1.Buffer.from(response.signed.authInfoBytes, "base64")
                        : new Uint8Array([]),
                },
            };
        });
    }
    signDirectAux(_chainId, _signer, _signDoc, _signOptions) {
        throw new Error("Not yet implemented");
    }
    signEthereum(chainId, signer, data, type) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkDeepLink();
            const topic = this.getCurrentTopic();
            const param = {
                topic,
                chainId: this.getNamespaceChainId(),
                request: {
                    method: "keplr_signEthereum",
                    params: {
                        chainId,
                        signer,
                        data,
                        type,
                    },
                },
            };
            return yield this.sendCustomRequest(param);
        });
    }
    signICNSAdr36(_chainId, _contractAddress, _owner, _username, _addressChainIds) {
        throw new Error("Not yet implemented");
    }
    suggestToken(_chainId, _contractAddress, _viewingKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const registeredToken = this.getRegisteredSuggestToken(_contractAddress);
            if (registeredToken) {
                return;
            }
            this.checkDeepLink();
            const topic = this.getCurrentTopic();
            const param = {
                topic,
                chainId: this.getNamespaceChainId(),
                request: {
                    method: "keplr_suggestToken",
                    params: {
                        chainId: _chainId,
                        contractAddress: _contractAddress,
                        viewingKey: _viewingKey,
                    },
                },
            };
            yield this.sendCustomRequest(param);
            this.saveRegisteredSuggestToken(_chainId, _contractAddress, _viewingKey);
        });
    }
    verifyArbitrary(_chainId, _signer, _data, _signature) {
        throw new Error("Not yet implemented");
    }
    sendEthereumTx(_chainId, _tx) {
        throw new Error("Not yet implemented");
    }
    suggestERC20(_chainId, _contractAddress) {
        throw new Error("Not yet implemented");
    }
    getStarknetKey(_chainId) {
        throw new Error("Not yet implemented");
    }
    getStarknetKeysSettled(_chainIds) {
        throw new Error("Not yet implemented");
    }
    signStarknetTx() {
        throw new Error("Not yet implemented");
    }
    signStarknetDeployAccountTransaction(_chainId, _transaction) {
        throw new Error("Not yet implemented");
    }
    getBitcoinKey(_chainId) {
        throw new Error("Not yet implemented");
    }
    getBitcoinKeysSettled(_chainIds) {
        throw new Error("Not yet implemented");
    }
    signPsbt(_chainId, _psbtHex, _options) {
        throw new Error("Method not implemented.");
    }
    signPsbts(_chainId, _psbtsHexes, _options) {
        throw new Error("Method not implemented.");
    }
}
exports.KeplrWalletConnectV2 = KeplrWalletConnectV2;
class MockEthereumProvider extends events_1.default {
    constructor() {
        super();
        this.chainId = null;
        this.selectedAddress = null;
        this.networkVersion = null;
        this.isKeplr = true;
        this.isMetaMask = true;
    }
    isConnected() {
        throw new Error("Method not implemented.");
    }
    request({}) {
        throw new Error("Not yet implemented");
    }
    enable() {
        throw new Error("Method not implemented.");
    }
    net_version() {
        throw new Error("Method not implemented.");
    }
}
//# sourceMappingURL=index.js.map