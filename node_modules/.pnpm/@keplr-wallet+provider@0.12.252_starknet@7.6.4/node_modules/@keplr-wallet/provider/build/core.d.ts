/// <reference types="node" />
import { ChainInfo, EthSignType, Keplr as IKeplr, KeplrIntereactionOptions, KeplrMode, KeplrSignOptions, Key, BroadcastMode, AminoSignResponse, StdSignDoc, StdTx, OfflineAminoSigner, StdSignature, DirectSignResponse, OfflineDirectSigner, ICNSAdr36Signatures, ChainInfoWithoutEndpoints, SecretUtils, SettledResponses, DirectAuxSignResponse, IEthereumProvider, IStarknetProvider, WalletEvents, SupportedPaymentType, IBitcoinProvider, Network as BitcoinNetwork, BitcoinSignMessageType, ChainType as BitcoinChainType, SignPsbtOptions, Inscription } from "@keplr-wallet/types";
import { MessageRequester } from "@keplr-wallet/router";
import Long from "long";
import { KeplrCoreTypes } from "./core-types";
import EventEmitter from "events";
import type { AccountInterface, Call, DeployAccountSignerDetails, InvocationsSignerDetails, ProviderInterface } from "starknet";
export declare class Keplr implements IKeplr, KeplrCoreTypes {
    readonly version: string;
    readonly mode: KeplrMode;
    protected readonly requester: MessageRequester;
    protected enigmaUtils: Map<string, SecretUtils>;
    defaultOptions: KeplrIntereactionOptions;
    constructor(version: string, mode: KeplrMode, requester: MessageRequester);
    ping(): Promise<void>;
    enable(chainIds: string | string[]): Promise<void>;
    isEnabled(chainIds: string | string[]): Promise<boolean>;
    disable(chainIds?: string | string[]): Promise<void>;
    experimentalSuggestChain(chainInfo: ChainInfo & {
        gasPriceStep?: {
            readonly low: number;
            readonly average: number;
            readonly high: number;
        };
    }): Promise<void>;
    getKey(chainId: string): Promise<Key>;
    getKeysSettled(chainIds: string[]): Promise<SettledResponses<Key>>;
    getChainInfosWithoutEndpoints(): Promise<ChainInfoWithoutEndpoints[]>;
    getChainInfoWithoutEndpoints(chainId: string): Promise<ChainInfoWithoutEndpoints>;
    sendTx(chainId: string, tx: StdTx | Uint8Array, mode: BroadcastMode): Promise<Uint8Array>;
    signAmino(chainId: string, signer: string, signDoc: StdSignDoc, signOptions?: KeplrSignOptions): Promise<AminoSignResponse>;
    signDirect(chainId: string, signer: string, signDoc: {
        bodyBytes?: Uint8Array | null;
        authInfoBytes?: Uint8Array | null;
        chainId?: string | null;
        accountNumber?: Long | null;
    }, signOptions?: KeplrSignOptions): Promise<DirectSignResponse>;
    signDirectAux(chainId: string, signer: string, signDoc: {
        bodyBytes?: Uint8Array | null;
        publicKey?: {
            typeUrl: string;
            value: Uint8Array;
        } | null;
        chainId?: string | null;
        accountNumber?: Long | null;
        sequence?: Long | null;
    }, signOptions?: Exclude<KeplrSignOptions, "preferNoSetFee" | "disableBalanceCheck">): Promise<DirectAuxSignResponse>;
    signArbitrary(chainId: string, signer: string, data: string | Uint8Array): Promise<StdSignature>;
    verifyArbitrary(chainId: string, signer: string, data: string | Uint8Array, signature: StdSignature): Promise<boolean>;
    signEthereum(chainId: string, signer: string, message: string | Uint8Array, signType: EthSignType): Promise<Uint8Array>;
    signICNSAdr36(chainId: string, contractAddress: string, owner: string, username: string, addressChainIds: string[]): Promise<ICNSAdr36Signatures>;
    getOfflineSigner(chainId: string, signOptions?: KeplrSignOptions): OfflineAminoSigner & OfflineDirectSigner;
    getOfflineSignerOnlyAmino(chainId: string, signOptions?: KeplrSignOptions): OfflineAminoSigner;
    getOfflineSignerAuto(chainId: string, signOptions?: KeplrSignOptions): Promise<OfflineAminoSigner | OfflineDirectSigner>;
    suggestToken(chainId: string, contractAddress: string, viewingKey?: string): Promise<void>;
    getSecret20ViewingKey(chainId: string, contractAddress: string): Promise<string>;
    getEnigmaPubKey(chainId: string): Promise<Uint8Array>;
    getEnigmaTxEncryptionKey(chainId: string, nonce: Uint8Array): Promise<Uint8Array>;
    enigmaEncrypt(chainId: string, contractCodeHash: string, msg: object): Promise<Uint8Array>;
    enigmaDecrypt(chainId: string, cipherText: Uint8Array, nonce: Uint8Array): Promise<Uint8Array>;
    getEnigmaUtils(chainId: string): SecretUtils;
    experimentalSignEIP712CosmosTx_v0(chainId: string, signer: string, eip712: {
        types: Record<string, {
            name: string;
            type: string;
        }[] | undefined>;
        domain: Record<string, any>;
        primaryType: string;
    }, signDoc: StdSignDoc, signOptions?: KeplrSignOptions): Promise<AminoSignResponse>;
    __core__getAnalyticsId(): Promise<string>;
    changeKeyRingName({ defaultName, editable, }: {
        defaultName: string;
        editable?: boolean;
    }): Promise<string>;
    __core__privilageSignAminoWithdrawRewards(chainId: string, signer: string, signDoc: StdSignDoc): Promise<AminoSignResponse>;
    __core__privilageSignAminoDelegate(chainId: string, signer: string, signDoc: StdSignDoc): Promise<AminoSignResponse>;
    __core__privilageSignAminoExecuteCosmWasm(chainId: string, signer: string, signDoc: StdSignDoc): Promise<AminoSignResponse>;
    sendEthereumTx(chainId: string, tx: Uint8Array): Promise<string>;
    suggestERC20(chainId: string, contractAddress: string): Promise<void>;
    __core__webpageClosed(): Promise<void>;
    getStarknetKey(chainId: string): Promise<{
        name: string;
        hexAddress: string;
        pubKey: Uint8Array;
        address: Uint8Array;
        isNanoLedger: boolean;
    }>;
    getStarknetKeysSettled(chainIds: string[]): Promise<SettledResponses<{
        name: string;
        hexAddress: string;
        pubKey: Uint8Array;
        address: Uint8Array;
        isNanoLedger: boolean;
    }>>;
    signStarknetTx(chainId: string, transactions: Call[], details: InvocationsSignerDetails): Promise<{
        transactions: Call[];
        details: InvocationsSignerDetails;
        signature: string[];
    }>;
    signStarknetDeployAccountTransaction(chainId: string, transaction: DeployAccountSignerDetails): Promise<{
        transaction: DeployAccountSignerDetails;
        signature: string[];
    }>;
    getBitcoinKey(chainId: string): Promise<{
        name: string;
        pubKey: Uint8Array;
        address: string;
        paymentType: SupportedPaymentType;
        isNanoLedger: boolean;
    }>;
    getBitcoinKeysSettled(chainIds: string[]): Promise<SettledResponses<{
        name: string;
        pubKey: Uint8Array;
        address: string;
        paymentType: SupportedPaymentType;
        isNanoLedger: boolean;
    }>>;
    signPsbt(chainId: string, psbtHex: string, options?: SignPsbtOptions): Promise<string>;
    signPsbts(chainId: string, psbtsHexes: string[], options?: SignPsbtOptions): Promise<string[]>;
    protectedTryOpenSidePanelIfEnabled(ignoreGestureFailure?: boolean): Promise<void>;
    readonly ethereum: EthereumProvider;
    readonly starknet: StarknetProvider;
    readonly bitcoin: BitcoinProvider;
}
declare class EthereumProvider extends EventEmitter implements IEthereumProvider {
    protected readonly keplr: Keplr;
    protected readonly requester: MessageRequester;
    chainId: string | null;
    selectedAddress: string | null;
    networkVersion: string | null;
    isKeplr: boolean;
    isMetaMask: boolean;
    constructor(keplr: Keplr, requester: MessageRequester);
    protected protectedEnableAccess(newCurrentChainId?: string): Promise<void>;
    protected protectedGetNewCurrentChainIdFromRequest(method: string, params?: readonly unknown[] | Record<string, unknown>): Promise<string | undefined>;
    protected protectedCheckNeedEnableAccess(method: string): Promise<boolean>;
    isConnected(): boolean;
    request<T = unknown>({ method, params, providerId, chainId, }: {
        method: string;
        params?: readonly unknown[] | Record<string, unknown>;
        providerId?: string;
        chainId?: string;
    }): Promise<T>;
    /**
     * Legacy methods
     */
    enable(): Promise<string[]>;
    net_version(): Promise<string>;
}
declare class StarknetProvider implements IStarknetProvider {
    protected readonly keplr: Keplr;
    protected readonly requester: MessageRequester;
    id: string;
    name: string;
    version: string;
    icon: string;
    isConnected: boolean;
    chainId?: string | undefined;
    selectedAddress?: string | undefined;
    account?: AccountInterface;
    provider?: ProviderInterface;
    constructor(keplr: Keplr, requester: MessageRequester);
    protected protectedEnableAccess(newCurrentChainId?: string): Promise<void>;
    protected protectedGetNewCurrentChainIdFromRequest(method: string, params?: readonly unknown[] | Record<string, unknown>): Promise<string | undefined>;
    protected protectedCheckNeedEnableAccess(method: string, params?: readonly unknown[] | Record<string, unknown>): Promise<boolean>;
    request<T = unknown>({ type, params, }: {
        type: string;
        params?: unknown[] | Record<string, unknown>;
    }): Promise<T>;
    enable(_options?: {
        starknetVersion?: "v4" | "v5";
    }): Promise<string[]>;
    isPreauthorized(): Promise<boolean>;
    on<E extends WalletEvents>(_event: E["type"], _handleEvent: E["handler"]): void;
    off<E extends WalletEvents>(_event: E["type"], _handleEvent: E["handler"]): void;
}
declare class BitcoinProvider extends EventEmitter implements IBitcoinProvider {
    protected readonly keplr: Keplr;
    protected readonly requester: MessageRequester;
    constructor(keplr: Keplr, requester: MessageRequester);
    protected protectedEnableAccess(): Promise<void>;
    getAccounts(): Promise<string[]>;
    requestAccounts(): Promise<string[]>;
    disconnect(): Promise<void>;
    getNetwork(): Promise<BitcoinNetwork>;
    switchNetwork(network: BitcoinNetwork): Promise<BitcoinNetwork>;
    getChain(): Promise<{
        enum: BitcoinChainType;
        name: string;
        network: BitcoinNetwork;
    }>;
    switchChain(chain: BitcoinChainType): Promise<BitcoinChainType>;
    getPublicKey(): Promise<string>;
    getBalance(): Promise<{
        confirmed: number;
        unconfirmed: number;
        total: number;
    }>;
    getInscriptions(offset?: number, limit?: number): Promise<{
        total: number;
        list: Inscription[];
    }>;
    signMessage(message: string, signType?: BitcoinSignMessageType): Promise<string>;
    sendBitcoin(to: string, amount: number): Promise<string>;
    pushTx(rawTxHex: string): Promise<string>;
    pushPsbt(psbtHex: string): Promise<string>;
    signPsbt(psbtHex: string, options?: SignPsbtOptions): Promise<string>;
    signPsbts(psbtsHexes: string[], options?: SignPsbtOptions): Promise<string[]>;
    getAddress(): Promise<string>;
    connectWallet(): Promise<string[]>;
}
export {};
