"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinProvider = exports.InjectedKeplr = exports.injectKeplrToWindow = void 0;
const types_1 = require("@keplr-wallet/types");
const router_1 = require("@keplr-wallet/router");
const enigma_1 = require("./enigma");
const cosmjs_1 = require("./cosmjs");
const deepmerge_1 = __importDefault(require("deepmerge"));
const long_1 = __importDefault(require("long"));
const events_1 = __importDefault(require("events"));
function defineUnwritablePropertyIfPossible(o, p, value) {
    const descriptor = Object.getOwnPropertyDescriptor(o, p);
    if (!descriptor || descriptor.writable) {
        if (!descriptor || descriptor.configurable) {
            Object.defineProperty(o, p, {
                value,
                writable: false,
            });
        }
        else {
            o[p] = value;
        }
    }
    else {
        console.warn(`Failed to inject ${p} from keplr. Probably, other wallet is trying to intercept Keplr`);
    }
}
function injectKeplrToWindow(keplr) {
    defineUnwritablePropertyIfPossible(window, "keplr", keplr);
    defineUnwritablePropertyIfPossible(window, "getOfflineSigner", keplr.getOfflineSigner);
    defineUnwritablePropertyIfPossible(window, "getOfflineSignerOnlyAmino", keplr.getOfflineSignerOnlyAmino);
    defineUnwritablePropertyIfPossible(window, "getOfflineSignerAuto", keplr.getOfflineSignerAuto);
    defineUnwritablePropertyIfPossible(window, "getEnigmaUtils", keplr.getEnigmaUtils);
    defineUnwritablePropertyIfPossible(window, "starknet_keplr", keplr.starknet);
    defineUnwritablePropertyIfPossible(window, "bitcoin_keplr", keplr.bitcoin);
}
exports.injectKeplrToWindow = injectKeplrToWindow;
/**
 * InjectedKeplr would be injected to the webpage.
 * In the webpage, it can't request any messages to the extension because it doesn't have any API related to the extension.
 * So, to request some methods of the extension, this will proxy the request to the content script that is injected to webpage on the extension level.
 * This will use `window.postMessage` to interact with the content script.
 */
class InjectedKeplr {
    static startProxy(keplr, metaId, eventListener = {
        addMessageListener: (fn) => window.addEventListener("message", fn),
        removeMessageListener: (fn) => window.removeEventListener("message", fn),
        postMessage: (message) => window.postMessage(message, window.location.origin),
    }, parseMessage) {
        const proxyRequestType = `proxy-request${metaId ? `-${metaId}` : ""}`;
        const fn = (e) => __awaiter(this, void 0, void 0, function* () {
            const message = parseMessage
                ? parseMessage(e.data)
                : e.data;
            if (!message ||
                // "proxy-request"는 legacy support를 위한 것임.
                (message.type !== proxyRequestType && message.type !== "proxy-request")) {
                return;
            }
            try {
                if (!message.id) {
                    throw new Error("Empty id");
                }
                if (message.method.startsWith("protected")) {
                    throw new Error("Rejected");
                }
                if (message.method === "version") {
                    throw new Error("Version is not function");
                }
                if (message.method === "mode") {
                    throw new Error("Mode is not function");
                }
                if (message.method === "defaultOptions") {
                    throw new Error("DefaultOptions is not function");
                }
                if (!keplr[message.method] ||
                    (message.method !== "ethereum" &&
                        message.method !== "starknet" &&
                        message.method !== "bitcoin" &&
                        typeof keplr[message.method] !== "function")) {
                    throw new Error(`Invalid method: ${message.method}`);
                }
                if (message.method === "getOfflineSigner") {
                    throw new Error("GetOfflineSigner method can't be proxy request");
                }
                if (message.method === "getOfflineSignerOnlyAmino") {
                    throw new Error("GetOfflineSignerOnlyAmino method can't be proxy request");
                }
                if (message.method === "getOfflineSignerAuto") {
                    throw new Error("GetOfflineSignerAuto method can't be proxy request");
                }
                if (message.method === "getEnigmaUtils") {
                    throw new Error("GetEnigmaUtils method can't be proxy request");
                }
                const method = message.method;
                const result = yield (() => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b;
                    if (method === "signDirect") {
                        return yield (() => __awaiter(this, void 0, void 0, function* () {
                            const receivedSignDoc = message.args[2];
                            const result = yield keplr.signDirect(message.args[0], message.args[1], {
                                bodyBytes: receivedSignDoc.bodyBytes,
                                authInfoBytes: receivedSignDoc.authInfoBytes,
                                chainId: receivedSignDoc.chainId,
                                accountNumber: receivedSignDoc.accountNumber
                                    ? long_1.default.fromString(receivedSignDoc.accountNumber)
                                    : null,
                            }, message.args[3]);
                            return {
                                signed: {
                                    bodyBytes: result.signed.bodyBytes,
                                    authInfoBytes: result.signed.authInfoBytes,
                                    chainId: result.signed.chainId,
                                    accountNumber: result.signed.accountNumber.toString(),
                                },
                                signature: result.signature,
                            };
                        }))();
                    }
                    if (method === "signDirectAux") {
                        return yield (() => __awaiter(this, void 0, void 0, function* () {
                            const receivedSignDoc = message.args[2];
                            const result = yield keplr.signDirectAux(message.args[0], message.args[1], {
                                bodyBytes: receivedSignDoc.bodyBytes,
                                publicKey: receivedSignDoc.publicKey,
                                chainId: receivedSignDoc.chainId,
                                accountNumber: receivedSignDoc.accountNumber
                                    ? long_1.default.fromString(receivedSignDoc.accountNumber)
                                    : null,
                                sequence: receivedSignDoc.sequence
                                    ? long_1.default.fromString(receivedSignDoc.sequence)
                                    : null,
                            }, message.args[3]);
                            return {
                                signed: {
                                    bodyBytes: result.signed.bodyBytes,
                                    publicKey: result.signed.publicKey,
                                    chainId: result.signed.chainId,
                                    accountNumber: result.signed.accountNumber.toString(),
                                    sequence: result.signed.sequence.toString(),
                                },
                                signature: result.signature,
                            };
                        }))();
                    }
                    if (method === "ethereum") {
                        const ethereumProviderMethod = message.ethereumProviderMethod;
                        if (ethereumProviderMethod === null || ethereumProviderMethod === void 0 ? void 0 : ethereumProviderMethod.startsWith("protected")) {
                            throw new Error("Rejected");
                        }
                        if (ethereumProviderMethod === "chainId") {
                            throw new Error("chainId is not function");
                        }
                        if (ethereumProviderMethod === "selectedAddress") {
                            throw new Error("selectedAddress is not function");
                        }
                        if (ethereumProviderMethod === "networkVersion") {
                            throw new Error("networkVersion is not function");
                        }
                        if (ethereumProviderMethod === "isKeplr") {
                            throw new Error("isKeplr is not function");
                        }
                        if (ethereumProviderMethod === "isMetaMask") {
                            throw new Error("isMetaMask is not function");
                        }
                        if (ethereumProviderMethod === undefined ||
                            typeof keplr.ethereum[ethereumProviderMethod] !== "function") {
                            throw new Error(`${message.ethereumProviderMethod} is not function or invalid Ethereum provider method`);
                        }
                        const messageArgs = router_1.JSONUint8Array.unwrap(message.args);
                        if (ethereumProviderMethod === "request") {
                            return yield keplr.ethereum.request(typeof messageArgs === "string"
                                ? JSON.parse(messageArgs)
                                : messageArgs);
                        }
                        return yield keplr.ethereum[ethereumProviderMethod](
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        ...(typeof messageArgs === "string"
                            ? JSON.parse(messageArgs)
                            : messageArgs));
                    }
                    if (method === "starknet") {
                        const starknetProviderMethod = message.starknetProviderMethod;
                        if (starknetProviderMethod === null || starknetProviderMethod === void 0 ? void 0 : starknetProviderMethod.startsWith("protected")) {
                            throw new Error("Rejected");
                        }
                        if (starknetProviderMethod === "id") {
                            throw new Error("id is not function");
                        }
                        if (starknetProviderMethod === "name") {
                            throw new Error("name is not function");
                        }
                        if (starknetProviderMethod === "version") {
                            throw new Error("version is not function");
                        }
                        if (starknetProviderMethod === "icon") {
                            throw new Error("icon is not function");
                        }
                        if (starknetProviderMethod === "chainId") {
                            throw new Error("chainId is not function");
                        }
                        if (starknetProviderMethod === "selectedAddress") {
                            throw new Error("selectedAddress is not function");
                        }
                        if (starknetProviderMethod === "isConnected") {
                            throw new Error("isConnected is not function");
                        }
                        if (starknetProviderMethod === "account") {
                            throw new Error("account is not function");
                        }
                        if (starknetProviderMethod === "provider") {
                            throw new Error("provider is not function");
                        }
                        if (starknetProviderMethod === undefined ||
                            typeof ((_a = keplr.starknet) === null || _a === void 0 ? void 0 : _a[starknetProviderMethod]) !== "function") {
                            throw new Error(`${message.starknetProviderMethod} is not function or invalid Starknet provider method`);
                        }
                        const messageArgs = router_1.JSONUint8Array.unwrap(message.args);
                        if (starknetProviderMethod === "request") {
                            return yield keplr.starknet.request(typeof messageArgs === "string"
                                ? JSON.parse(messageArgs)
                                : messageArgs);
                        }
                        return yield keplr.starknet[starknetProviderMethod](
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        ...(typeof messageArgs === "string"
                            ? JSON.parse(messageArgs)
                            : messageArgs));
                    }
                    if (method === "bitcoin") {
                        const bitcoinProviderMethod = message.bitcoinProviderMethod;
                        if (bitcoinProviderMethod === null || bitcoinProviderMethod === void 0 ? void 0 : bitcoinProviderMethod.startsWith("protected")) {
                            throw new Error("Rejected");
                        }
                        if (bitcoinProviderMethod === undefined ||
                            typeof ((_b = keplr.bitcoin) === null || _b === void 0 ? void 0 : _b[bitcoinProviderMethod]) !== "function") {
                            throw new Error(`${message.bitcoinProviderMethod} is not function or invalid Bitcoin provider method`);
                        }
                        const messageArgs = router_1.JSONUint8Array.unwrap(message.args);
                        return yield keplr.bitcoin[bitcoinProviderMethod](
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        ...(typeof messageArgs === "string"
                            ? JSON.parse(messageArgs)
                            : messageArgs));
                    }
                    return yield keplr[method](
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    ...router_1.JSONUint8Array.unwrap(message.args));
                }))();
                const proxyResponse = {
                    type: "proxy-request-response",
                    id: message.id,
                    result: {
                        return: router_1.JSONUint8Array.wrap(result),
                    },
                };
                eventListener.postMessage(proxyResponse);
            }
            catch (e) {
                const proxyResponse = {
                    type: "proxy-request-response",
                    id: message.id,
                    result: {
                        error: e.code && !e.module
                            ? {
                                code: e.code,
                                message: e.message,
                                data: e.data,
                            }
                            : e.message || e.toString(),
                    },
                };
                eventListener.postMessage(proxyResponse);
            }
        });
        eventListener.addMessageListener(fn);
        return () => {
            eventListener.removeMessageListener(fn);
        };
    }
    requestMethod(method, args) {
        const bytes = new Uint8Array(8);
        const id = Array.from(crypto.getRandomValues(bytes))
            .map((value) => {
            return value.toString(16);
        })
            .join("");
        const proxyRequestType = `proxy-request${this.metaId ? `-${this.metaId}` : ""}`;
        const proxyMessage = {
            type: proxyRequestType,
            id,
            method,
            args: router_1.JSONUint8Array.wrap(args),
        };
        return new Promise((resolve, reject) => {
            const receiveResponse = (e) => {
                const proxyResponse = this.parseMessage
                    ? this.parseMessage(e.data)
                    : e.data;
                if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
                    return;
                }
                if (proxyResponse.id !== id) {
                    return;
                }
                this.eventListener.removeMessageListener(receiveResponse);
                const result = router_1.JSONUint8Array.unwrap(proxyResponse.result);
                if (!result) {
                    reject(new Error("Result is null"));
                    return;
                }
                if (result.error) {
                    reject(new Error(result.error));
                    return;
                }
                resolve(result.return);
            };
            this.eventListener.addMessageListener(receiveResponse);
            this.eventListener.postMessage(proxyMessage);
        });
    }
    constructor(metaId, version, mode, onStarknetStateChange, onStarknetAccountChange, eventListener = {
        addMessageListener: (fn) => window.addEventListener("message", fn),
        removeMessageListener: (fn) => window.removeEventListener("message", fn),
        postMessage: (message) => window.postMessage(message, window.location.origin),
    }, parseMessage, eip6963ProviderInfo, starknetProviderInfo) {
        this.metaId = metaId;
        this.version = version;
        this.mode = mode;
        this.onStarknetStateChange = onStarknetStateChange;
        this.onStarknetAccountChange = onStarknetAccountChange;
        this.eventListener = eventListener;
        this.parseMessage = parseMessage;
        this.eip6963ProviderInfo = eip6963ProviderInfo;
        this.starknetProviderInfo = starknetProviderInfo;
        this.enigmaUtils = new Map();
        this.defaultOptions = {};
        this.ethereum = new EthereumProvider(this.metaId, () => this, this.eventListener, this.parseMessage, this.eip6963ProviderInfo);
        this.starknet = this.generateStarknetProvider();
        this.bitcoin = new BitcoinProvider(() => this, this.eventListener, this.parseMessage);
        // Freeze fields/method except for "defaultOptions"
        // Intentionally, "defaultOptions" can be mutated to allow a webpage to change the options with cosmjs usage.
        // Freeze fields
        const fieldNames = Object.keys(this);
        for (const fieldName of fieldNames) {
            if (fieldName !== "defaultOptions") {
                Object.defineProperty(this, fieldName, {
                    value: this[fieldName],
                    writable: false,
                });
            }
            // If field is "eventListener", try to iterate one-level deep.
            if (fieldName === "eventListener") {
                const fieldNames = Object.keys(this.eventListener);
                for (const fieldName of fieldNames) {
                    Object.defineProperty(this.eventListener, fieldName, {
                        value: this.eventListener[fieldName],
                        writable: false,
                    });
                }
            }
        }
        // Freeze methods
        const methodNames = Object.getOwnPropertyNames(InjectedKeplr.prototype);
        for (const methodName of methodNames) {
            if (methodName !== "constructor" &&
                typeof this[methodName] === "function") {
                Object.defineProperty(this, methodName, {
                    value: this[methodName].bind(this),
                    writable: false,
                });
            }
        }
    }
    ping() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.requestMethod("ping", []);
        });
    }
    enable(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.requestMethod("enable", [chainIds]);
        });
    }
    disable(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.requestMethod("disable", [chainIds]);
        });
    }
    experimentalSuggestChain(chainInfo) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (chainInfo.hideInUI) {
                throw new Error("hideInUI is not allowed");
            }
            if (((_a = chainInfo.features) === null || _a === void 0 ? void 0 : _a.includes("stargate")) ||
                ((_b = chainInfo.features) === null || _b === void 0 ? void 0 : _b.includes("no-legacy-stdTx"))) {
                console.warn("“stargate”, “no-legacy-stdTx” feature has been deprecated. The launchpad is no longer supported, thus works without the two features. We would keep the aforementioned two feature for a while, but the upcoming update would potentially cause errors. Remove the two feature.");
            }
            yield this.requestMethod("experimentalSuggestChain", [chainInfo]);
        });
    }
    getKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getKey", [chainId]);
        });
    }
    getKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getKeysSettled", [chainIds]);
        });
    }
    sendTx(chainId, tx, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!("length" in tx)) {
                console.warn("Do not send legacy std tx via `sendTx` API. We now only support protobuf tx. The usage of legeacy std tx would throw an error in the near future.");
            }
            return yield this.requestMethod("sendTx", [chainId, tx, mode]);
        });
    }
    signAmino(chainId, signer, signDoc, signOptions = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signAmino", [
                chainId,
                signer,
                signDoc,
                (0, deepmerge_1.default)((_a = this.defaultOptions.sign) !== null && _a !== void 0 ? _a : {}, signOptions),
            ]);
        });
    }
    signDirect(chainId, signer, signDoc, signOptions = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.requestMethod("signDirect", [
                chainId,
                signer,
                // We can't send the `Long` with remaing the type.
                // Receiver should change the `string` to `Long`.
                {
                    bodyBytes: signDoc.bodyBytes,
                    authInfoBytes: signDoc.authInfoBytes,
                    chainId: signDoc.chainId,
                    accountNumber: signDoc.accountNumber
                        ? signDoc.accountNumber.toString()
                        : null,
                },
                (0, deepmerge_1.default)((_a = this.defaultOptions.sign) !== null && _a !== void 0 ? _a : {}, signOptions),
            ]);
            const signed = result.signed;
            return {
                signed: {
                    bodyBytes: signed.bodyBytes,
                    authInfoBytes: signed.authInfoBytes,
                    chainId: signed.chainId,
                    // We can't send the `Long` with remaing the type.
                    // Sender should change the `Long` to `string`.
                    accountNumber: long_1.default.fromString(signed.accountNumber),
                },
                signature: result.signature,
            };
        });
    }
    signDirectAux(chainId, signer, signDoc, signOptions = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.requestMethod("signDirectAux", [
                chainId,
                signer,
                // We can't send the `Long` with remaing the type.
                // Receiver should change the `string` to `Long`.
                {
                    bodyBytes: signDoc.bodyBytes,
                    publicKey: signDoc.publicKey,
                    chainId: signDoc.chainId,
                    accountNumber: signDoc.accountNumber
                        ? signDoc.accountNumber.toString()
                        : null,
                    sequence: signDoc.sequence ? signDoc.sequence.toString() : null,
                },
                (0, deepmerge_1.default)({
                    preferNoSetMemo: (_a = this.defaultOptions.sign) === null || _a === void 0 ? void 0 : _a.preferNoSetMemo,
                }, signOptions),
            ]);
            const signed = result.signed;
            return {
                signed: {
                    bodyBytes: signed.bodyBytes,
                    publicKey: signed.publicKey || undefined,
                    chainId: signed.chainId,
                    // We can't send the `Long` with remaing the type.
                    // Sender should change the `Long` to `string`.
                    accountNumber: long_1.default.fromString(signed.accountNumber),
                    sequence: long_1.default.fromString(signed.sequence),
                },
                signature: result.signature,
            };
        });
    }
    signArbitrary(chainId, signer, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signArbitrary", [chainId, signer, data]);
        });
    }
    signICNSAdr36(chainId, contractAddress, owner, username, addressChainIds) {
        return this.requestMethod("signICNSAdr36", [
            chainId,
            contractAddress,
            owner,
            username,
            addressChainIds,
        ]);
    }
    verifyArbitrary(chainId, signer, data, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("verifyArbitrary", [
                chainId,
                signer,
                data,
                signature,
            ]);
        });
    }
    signEthereum(chainId, signer, data, type) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signEthereum", [
                chainId,
                signer,
                data,
                type,
            ]);
        });
    }
    getOfflineSigner(chainId, signOptions) {
        return new cosmjs_1.CosmJSOfflineSigner(chainId, this, signOptions);
    }
    getOfflineSignerOnlyAmino(chainId, signOptions) {
        return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this, signOptions);
    }
    getOfflineSignerAuto(chainId, signOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield this.getKey(chainId);
            if (key.isNanoLedger) {
                return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this, signOptions);
            }
            return new cosmjs_1.CosmJSOfflineSigner(chainId, this, signOptions);
        });
    }
    suggestToken(chainId, contractAddress, viewingKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("suggestToken", [
                chainId,
                contractAddress,
                viewingKey,
            ]);
        });
    }
    getSecret20ViewingKey(chainId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getSecret20ViewingKey", [
                chainId,
                contractAddress,
            ]);
        });
    }
    getEnigmaPubKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getEnigmaPubKey", [chainId]);
        });
    }
    getEnigmaTxEncryptionKey(chainId, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getEnigmaTxEncryptionKey", [
                chainId,
                nonce,
            ]);
        });
    }
    enigmaEncrypt(chainId, contractCodeHash, 
    // eslint-disable-next-line @typescript-eslint/ban-types
    msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("enigmaEncrypt", [
                chainId,
                contractCodeHash,
                msg,
            ]);
        });
    }
    enigmaDecrypt(chainId, ciphertext, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("enigmaDecrypt", [
                chainId,
                ciphertext,
                nonce,
            ]);
        });
    }
    getEnigmaUtils(chainId) {
        if (this.enigmaUtils.has(chainId)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.enigmaUtils.get(chainId);
        }
        const enigmaUtils = new enigma_1.KeplrEnigmaUtils(chainId, this);
        this.enigmaUtils.set(chainId, enigmaUtils);
        return enigmaUtils;
    }
    experimentalSignEIP712CosmosTx_v0(chainId, signer, eip712, signDoc, signOptions = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("experimentalSignEIP712CosmosTx_v0", [
                chainId,
                signer,
                eip712,
                signDoc,
                (0, deepmerge_1.default)((_a = this.defaultOptions.sign) !== null && _a !== void 0 ? _a : {}, signOptions),
            ]);
        });
    }
    getChainInfosWithoutEndpoints() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getChainInfosWithoutEndpoints", []);
        });
    }
    getChainInfoWithoutEndpoints(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getChainInfoWithoutEndpoints", [chainId]);
        });
    }
    __core__getAnalyticsId() {
        return this.requestMethod("__core__getAnalyticsId", []);
    }
    changeKeyRingName({ defaultName, editable = true, }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("changeKeyRingName", [
                { defaultName, editable },
            ]);
        });
    }
    __core__privilageSignAminoWithdrawRewards(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("__core__privilageSignAminoWithdrawRewards", [chainId, signer, signDoc]);
        });
    }
    __core__privilageSignAminoDelegate(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("__core__privilageSignAminoDelegate", [
                chainId,
                signer,
                signDoc,
            ]);
        });
    }
    __core__privilageSignAminoExecuteCosmWasm(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("__core__privilageSignAminoExecuteCosmWasm", [chainId, signer, signDoc]);
        });
    }
    sendEthereumTx(chainId, tx) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("sendEthereumTx", [chainId, tx]);
        });
    }
    suggestERC20(chainId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("suggestERC20", [chainId, contractAddress]);
        });
    }
    __core__webpageClosed() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("__core__webpageClosed", []);
        });
    }
    getStarknetKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getStarknetKey", [chainId]);
        });
    }
    getStarknetKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getStarknetKeysSettled", [chainIds]);
        });
    }
    signStarknetTx(chainId, transactions, details) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signStarknetTx", [
                chainId,
                transactions,
                details,
            ]);
        });
    }
    signStarknetDeployAccountTransaction(chainId, transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signStarknetDeployAccountTransaction", [
                chainId,
                transaction,
            ]);
        });
    }
    generateStarknetProvider() {
        return new StarknetProvider(this.metaId, this.starknetProviderInfo.id, this.starknetProviderInfo.name, this.version, this.starknetProviderInfo.icon, () => this, this.onStarknetStateChange, this.onStarknetAccountChange, this.eventListener, this.parseMessage);
    }
    getBitcoinKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getBitcoinKey", [chainId]);
        });
    }
    getBitcoinKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getBitcoinKeysSettled", [chainIds]);
        });
    }
    signPsbt(chainId, psbtHex, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signPsbt", [chainId, psbtHex, options]);
        });
    }
    signPsbts(chainId, psbtsHexes, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signPsbts", [
                chainId,
                psbtsHexes,
                options,
            ]);
        });
    }
}
exports.InjectedKeplr = InjectedKeplr;
class EthereumProvider extends events_1.default {
    constructor(metaId, injectedKeplr, eventListener = {
        addMessageListener: (fn) => window.addEventListener("message", fn),
        removeMessageListener: (fn) => window.removeEventListener("message", fn),
        postMessage: (message) => window.postMessage(message, window.location.origin),
    }, parseMessage, eip6963ProviderInfo) {
        super();
        this.metaId = metaId;
        this.injectedKeplr = injectedKeplr;
        this.eventListener = eventListener;
        this.parseMessage = parseMessage;
        this.eip6963ProviderInfo = eip6963ProviderInfo;
        // It must be in the hexadecimal format used in EVM-based chains, not the format used in Tendermint nodes.
        this.chainId = null;
        // It must be in the decimal format of chainId.
        this.networkVersion = null;
        this.selectedAddress = null;
        this.isKeplr = true;
        this.isMetaMask = true;
        this._isConnected = false;
        this._currentChainId = null;
        this._requestMethod = (method, args) => __awaiter(this, void 0, void 0, function* () {
            const bytes = new Uint8Array(8);
            const id = Array.from(crypto.getRandomValues(bytes))
                .map((value) => {
                return value.toString(16);
            })
                .join("");
            const proxyRequestType = `proxy-request${this.metaId ? `-${this.metaId}` : ""}`;
            const proxyMessage = {
                type: proxyRequestType,
                id,
                method: "ethereum",
                args: router_1.JSONUint8Array.wrap(args),
                ethereumProviderMethod: method,
            };
            return new Promise((resolve, reject) => {
                const receiveResponse = (e) => {
                    const proxyResponse = this.parseMessage
                        ? this.parseMessage(e.data)
                        : e.data;
                    if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
                        return;
                    }
                    if (proxyResponse.id !== id) {
                        return;
                    }
                    this.eventListener.removeMessageListener(receiveResponse);
                    const result = router_1.JSONUint8Array.unwrap(proxyResponse.result);
                    if (!result) {
                        reject(new Error("Result is null"));
                        return;
                    }
                    if (result.error) {
                        const error = result.error;
                        reject(error.code && !error.module
                            ? new router_1.EthereumProviderRpcError(error.code, error.message, error.data)
                            : new Error(error));
                        return;
                    }
                    resolve(result.return);
                };
                this.eventListener.addMessageListener(receiveResponse);
                this.eventListener.postMessage(proxyMessage);
            });
        });
        this._initProviderState = () => __awaiter(this, void 0, void 0, function* () {
            const initialProviderState = yield this._requestMethod("request", {
                method: "keplr_initProviderState",
            });
            if (initialProviderState) {
                const { currentEvmChainId, currentChainId, selectedAddress } = initialProviderState;
                if (currentChainId != null &&
                    currentEvmChainId != null &&
                    selectedAddress != null) {
                    this._handleConnect(currentEvmChainId);
                    this._handleChainChanged(currentEvmChainId);
                    this._currentChainId = currentChainId;
                    this._handleAccountsChanged(selectedAddress);
                }
            }
        });
        this._handleConnect = (evmChainId) => __awaiter(this, void 0, void 0, function* () {
            if (!this._isConnected) {
                this._isConnected = true;
                const evmChainIdHexString = `0x${evmChainId.toString(16)}`;
                this.emit("connect", { chainId: evmChainIdHexString });
            }
        });
        this._handleDisconnect = () => __awaiter(this, void 0, void 0, function* () {
            if (this._isConnected) {
                yield this._requestMethod("request", {
                    method: "keplr_disconnect",
                });
                this._isConnected = false;
                this.chainId = null;
                this.selectedAddress = null;
                this.networkVersion = null;
                this.emit("disconnect");
            }
        });
        this._handleChainChanged = (evmChainId) => __awaiter(this, void 0, void 0, function* () {
            const evmChainIdHexString = `0x${evmChainId.toString(16)}`;
            if (evmChainIdHexString !== this.chainId) {
                this.chainId = evmChainIdHexString;
                this.networkVersion = evmChainId.toString(10);
                this.emit("chainChanged", evmChainIdHexString);
            }
        });
        this._handleAccountsChanged = (selectedAddress) => __awaiter(this, void 0, void 0, function* () {
            if (this.selectedAddress !== selectedAddress) {
                this.selectedAddress = selectedAddress;
                this.emit("accountsChanged", [selectedAddress]);
            }
        });
        this.request = ({ method, params, chainId, }) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (typeof method !== "string") {
                throw new Error("Invalid paramater: `method` must be a string");
            }
            if (!this._isConnected) {
                yield this._initProviderState();
            }
            return yield this._requestMethod("request", {
                method,
                params,
                providerId: (_a = this.eip6963ProviderInfo) === null || _a === void 0 ? void 0 : _a.uuid,
                chainId,
            });
        });
        this.enable = () => __awaiter(this, void 0, void 0, function* () {
            return (yield this.request({
                method: "eth_requestAccounts",
            }));
        });
        this.net_version = () => __awaiter(this, void 0, void 0, function* () {
            return (yield this.request({
                method: "net_version",
            }));
        });
        this._initProviderState();
        window.addEventListener("keplr_keystorechange", () => __awaiter(this, void 0, void 0, function* () {
            if (this._currentChainId) {
                const chainInfo = yield injectedKeplr().getChainInfoWithoutEndpoints(this._currentChainId);
                if (chainInfo) {
                    const selectedAddress = (yield injectedKeplr().getKey(this._currentChainId)).ethereumHexAddress;
                    this._handleAccountsChanged(selectedAddress);
                }
            }
        }));
        window.addEventListener("keplr_chainChanged", (event) => {
            const origin = event.detail.origin;
            if (origin === window.location.origin) {
                const evmChainId = event.detail.evmChainId;
                this._handleChainChanged(evmChainId);
            }
        });
        window.addEventListener("keplr_ethSubscription", (event) => {
            var _a;
            const origin = event.detail.origin;
            const providerId = event.detail.providerId;
            if (origin === window.location.origin &&
                providerId === ((_a = this.eip6963ProviderInfo) === null || _a === void 0 ? void 0 : _a.uuid)) {
                const data = event.detail.data;
                this.emit("message", {
                    type: "eth_subscription",
                    data,
                });
            }
        });
        if (this.eip6963ProviderInfo) {
            const announceEvent = new CustomEvent(types_1.EIP6963EventNames.Announce, {
                detail: Object.freeze({
                    info: this.eip6963ProviderInfo,
                    provider: this,
                }),
            });
            window.addEventListener(types_1.EIP6963EventNames.Request, () => window.dispatchEvent(announceEvent));
            window.dispatchEvent(announceEvent);
        }
    }
    isConnected() {
        return this._isConnected;
    }
}
class StarknetProvider {
    constructor(metaId, id, name, version, icon, _injectedKeplr, onStateChange, onAccountChange, _eventListener = {
        addMessageListener: (fn) => window.addEventListener("message", fn),
        removeMessageListener: (fn) => window.removeEventListener("message", fn),
        postMessage: (message) => window.postMessage(message, window.location.origin),
    }, _parseMessage) {
        this.metaId = metaId;
        this.id = id;
        this.name = name;
        this.version = version;
        this.icon = icon;
        this._injectedKeplr = _injectedKeplr;
        this.onStateChange = onStateChange;
        this.onAccountChange = onAccountChange;
        this._eventListener = _eventListener;
        this._parseMessage = _parseMessage;
        this.isConnected = false;
        // It must be in plain text format not hexadecimal string. e.g. "SN_MAIN"
        this.chainId = undefined;
        this.selectedAddress = undefined;
        this.account = undefined;
        this.provider = undefined;
        // It must be in the CAIP-2 chain ID format. e.g. "starknet:SN_MAIN"
        this._currentChainId = undefined;
        this._userWalletEvents = [];
        this._initProviderState();
        window.addEventListener("keplr_keystorechange", () => __awaiter(this, void 0, void 0, function* () {
            if (this._currentChainId) {
                const selectedAddress = (yield this._injectedKeplr().getStarknetKey(this._currentChainId)).hexAddress;
                this.selectedAddress = selectedAddress;
                this.onAccountChange({
                    selectedAddress,
                });
                this._userWalletEvents.forEach((userWalletEvent) => {
                    if (userWalletEvent.type === "accountsChanged") {
                        userWalletEvent.handler([selectedAddress]);
                    }
                });
            }
        }));
        window.addEventListener("keplr_starknetChainChanged", (event) => {
            const origin = event.detail.origin;
            const starknetChainId = event.detail.starknetChainId;
            this.chainId = starknetChainId;
            if (origin === window.location.origin) {
                this._userWalletEvents.forEach((userWalletEvent) => {
                    if (userWalletEvent.type === "networkChanged") {
                        userWalletEvent.handler(starknetChainId);
                    }
                });
            }
        });
    }
    _requestMethod(method, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const bytes = new Uint8Array(8);
            const id = Array.from(crypto.getRandomValues(bytes))
                .map((value) => {
                return value.toString(16);
            })
                .join("");
            const proxyRequestType = `proxy-request${this.metaId ? `-${this.metaId}` : ""}`;
            const proxyMessage = {
                type: proxyRequestType,
                id,
                method: "starknet",
                args: router_1.JSONUint8Array.wrap(args),
                starknetProviderMethod: method,
            };
            return new Promise((resolve, reject) => {
                const receiveResponse = (e) => {
                    const proxyResponse = this._parseMessage
                        ? this._parseMessage(e.data)
                        : e.data;
                    if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
                        return;
                    }
                    if (proxyResponse.id !== id) {
                        return;
                    }
                    this._eventListener.removeMessageListener(receiveResponse);
                    const result = router_1.JSONUint8Array.unwrap(proxyResponse.result);
                    if (!result) {
                        reject(new Error("Result is null"));
                        return;
                    }
                    if (result.error) {
                        const error = result.error;
                        reject(error.code && !error.module
                            ? new router_1.EthereumProviderRpcError(error.code, error.message, error.data)
                            : new Error(error));
                        return;
                    }
                    resolve(result.return);
                };
                this._eventListener.addMessageListener(receiveResponse);
                this._eventListener.postMessage(proxyMessage);
            });
        });
    }
    _initProviderState() {
        return __awaiter(this, void 0, void 0, function* () {
            const { currentChainId, selectedAddress, rpc } = yield this.request({
                type: "keplr_initStarknetProviderState",
            });
            if (currentChainId != null && selectedAddress != null && rpc != null) {
                this.onStateChange({
                    selectedAddress,
                    chainId: currentChainId,
                    rpc,
                });
                this._currentChainId = currentChainId;
                this.chainId = currentChainId.replace("starknet:", "");
                this.selectedAddress = selectedAddress;
                this.isConnected = true;
            }
            else {
                this.onStateChange({
                    selectedAddress: null,
                    chainId: null,
                    rpc: null,
                });
            }
        });
    }
    request({ type, params, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof type !== "string") {
                throw new Error("Invalid parameter: `type` must be a string");
            }
            return yield this._requestMethod("request", {
                type,
                params,
            });
        });
    }
    enable(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { currentChainId, selectedAddress, rpc } = yield this.request({
                type: "keplr_enableStarknetProvider",
            });
            this.onStateChange({
                selectedAddress,
                chainId: currentChainId,
                rpc,
            });
            this._currentChainId = currentChainId;
            this.chainId = currentChainId.replace("starknet:", "");
            this.selectedAddress = selectedAddress;
            this.isConnected = true;
            return [selectedAddress];
        });
    }
    isPreauthorized() {
        return __awaiter(this, void 0, void 0, function* () {
            const { currentChainId, selectedAddress } = yield this.request({
                type: "keplr_initStarknetProviderState",
            });
            if (currentChainId != null && selectedAddress != null) {
                return true;
            }
            return false;
        });
    }
    on(event, handleEvent) {
        if (event === "accountsChanged") {
            this._userWalletEvents.push({
                type: "accountsChanged",
                handler: handleEvent,
            });
        }
        else if (event === "networkChanged") {
            this._userWalletEvents.push({
                type: "networkChanged",
                handler: handleEvent,
            });
        }
        else {
            throw new Error("Invalid event type");
        }
    }
    off(event, handleEvent) {
        if (event !== "accountsChanged" && event !== "networkChanged") {
            throw new Error("Invalid event type");
        }
        const eventIndex = this._userWalletEvents.findIndex((userEvent) => userEvent.type === event && userEvent.handler === handleEvent);
        if (eventIndex >= 0) {
            this._userWalletEvents.splice(eventIndex, 1);
        }
    }
}
class BitcoinProvider extends events_1.default {
    constructor(_injectedKeplr, _eventListener = {
        addMessageListener: (fn) => window.addEventListener("message", fn),
        removeMessageListener: (fn) => window.removeEventListener("message", fn),
        postMessage: (message) => window.postMessage(message, window.location.origin),
    }, _parseMessage) {
        super();
        this._injectedKeplr = _injectedKeplr;
        this._eventListener = _eventListener;
        this._parseMessage = _parseMessage;
        this._handleNetworkChanged = (network) => __awaiter(this, void 0, void 0, function* () {
            this.emit("networkChanged", network);
        });
        this._handleAccountsChanged = (selectedAddress) => __awaiter(this, void 0, void 0, function* () {
            this.emit("accountChanged", [selectedAddress]);
            this.emit("accountsChanged", [selectedAddress]);
        });
        window.addEventListener("keplr_keystorechange", () => __awaiter(this, void 0, void 0, function* () {
            const accounts = yield this.getAccounts();
            if (accounts && accounts.length > 0) {
                this._handleAccountsChanged(accounts[0]);
            }
        }));
        window.addEventListener("keplr_bitcoinChainChanged", (event) => __awaiter(this, void 0, void 0, function* () {
            const origin = event.detail.origin;
            if (origin === window.location.origin) {
                const network = event.detail.network;
                const accounts = yield this.getAccounts();
                this._handleNetworkChanged(network);
                this._handleAccountsChanged(accounts[0]);
            }
        }));
        window.addEventListener("keplr_bitcoinAccountsChanged", () => __awaiter(this, void 0, void 0, function* () {
            const accounts = yield this.getAccounts();
            if (accounts && accounts.length > 0) {
                this._handleAccountsChanged(accounts[0]);
            }
        }));
    }
    _requestMethod(method, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const bytes = new Uint8Array(8);
            const id = Array.from(crypto.getRandomValues(bytes))
                .map((value) => {
                return value.toString(16);
            })
                .join("");
            const proxyMessage = {
                type: "proxy-request",
                id,
                method: "bitcoin",
                args: router_1.JSONUint8Array.wrap(args),
                bitcoinProviderMethod: method,
            };
            return new Promise((resolve, reject) => {
                const receiveResponse = (e) => {
                    const proxyResponse = this._parseMessage
                        ? this._parseMessage(e.data)
                        : e.data;
                    if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
                        return;
                    }
                    if (proxyResponse.id !== id) {
                        return;
                    }
                    this._eventListener.removeMessageListener(receiveResponse);
                    const result = router_1.JSONUint8Array.unwrap(proxyResponse.result);
                    if (!result) {
                        reject(new Error("Result is null"));
                        return;
                    }
                    // TODO: Handle error correctly
                    if (result.error) {
                        reject(new Error(result.error));
                        return;
                    }
                    resolve(result.return);
                };
                this._eventListener.addMessageListener(receiveResponse);
                this._eventListener.postMessage(proxyMessage);
            });
        });
    }
    getAccounts() {
        return this._requestMethod("getAccounts", []);
    }
    requestAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("requestAccounts", []);
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("disconnect", []);
        });
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("getNetwork", []);
        });
    }
    switchNetwork(network) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("switchNetwork", [network]);
        });
    }
    getChain() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("getChain", []);
        });
    }
    switchChain(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("switchChain", [chain]);
        });
    }
    getPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("getPublicKey", []);
        });
    }
    getBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("getBalance", []);
        });
    }
    getInscriptions(offset, limit) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("getInscriptions", [offset, limit]);
        });
    }
    signMessage(message, type) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("signMessage", [message, type]);
        });
    }
    sendBitcoin(to, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("sendBitcoin", [to, amount]);
        });
    }
    pushTx(rawTxHex) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("pushTx", [rawTxHex]);
        });
    }
    pushPsbt(psbtHex) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("pushPsbt", [psbtHex]);
        });
    }
    signPsbt(psbtHex, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("signPsbt", [psbtHex, options]);
        });
    }
    signPsbts(psbtsHexes, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._requestMethod("signPsbts", [psbtsHexes, options]);
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const accounts = yield this.getAccounts();
            return accounts[0];
        });
    }
    connectWallet() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestAccounts();
        });
    }
}
exports.BitcoinProvider = BitcoinProvider;
//# sourceMappingURL=inject.js.map