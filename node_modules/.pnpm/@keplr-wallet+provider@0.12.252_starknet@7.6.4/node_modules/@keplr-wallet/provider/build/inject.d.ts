/// <reference types="node" />
import { ChainInfo, EthSignType, Keplr, Keplr as IKeplr, KeplrIntereactionOptions, KeplrMode, KeplrSignOptions, Key, BroadcastMode, AminoSignResponse, StdSignDoc, OfflineAminoSigner, StdSignature, StdTx, DirectSignResponse, OfflineDirectSigner, ICNSAdr36Signatures, ChainInfoWithoutEndpoints, SecretUtils, SettledResponses, DirectAuxSignResponse, IEthereumProvider, EIP6963ProviderInfo, IStarknetProvider, SupportedPaymentType, IBitcoinProvider, Network as BitcoinNetwork, BitcoinSignMessageType, ChainType as BitcoinChainType, SignPsbtOptions, Inscription } from "@keplr-wallet/types";
import { Result } from "@keplr-wallet/router";
import Long from "long";
import { KeplrCoreTypes } from "./core-types";
import EventEmitter from "events";
import type { Call, DeployAccountSignerDetails, InvocationsSignerDetails } from "starknet";
export interface ProxyRequest {
    type: string;
    id: string;
    method: keyof (Keplr & KeplrCoreTypes);
    args: any[];
    ethereumProviderMethod?: keyof IEthereumProvider;
    starknetProviderMethod?: keyof IStarknetProvider;
    bitcoinProviderMethod?: keyof IBitcoinProvider;
}
export interface ProxyRequestResponse {
    type: "proxy-request-response";
    id: string;
    result: Result | undefined;
}
export declare function injectKeplrToWindow(keplr: IKeplr): void;
/**
 * InjectedKeplr would be injected to the webpage.
 * In the webpage, it can't request any messages to the extension because it doesn't have any API related to the extension.
 * So, to request some methods of the extension, this will proxy the request to the content script that is injected to webpage on the extension level.
 * This will use `window.postMessage` to interact with the content script.
 */
export declare class InjectedKeplr implements IKeplr, KeplrCoreTypes {
    protected readonly metaId: string | undefined;
    readonly version: string;
    readonly mode: KeplrMode;
    protected readonly onStarknetStateChange: (state: {
        selectedAddress: string | null;
        chainId: string | null;
        rpc: string | null;
    }) => void;
    protected readonly onStarknetAccountChange: (state: {
        selectedAddress: string | null;
    }) => void;
    protected readonly eventListener: {
        addMessageListener: (fn: (e: any) => void) => void;
        removeMessageListener: (fn: (e: any) => void) => void;
        postMessage: (message: any) => void;
    };
    protected readonly parseMessage: ((message: any) => any) | undefined;
    protected readonly eip6963ProviderInfo: EIP6963ProviderInfo | undefined;
    protected readonly starknetProviderInfo: {
        id: string;
        name: string;
        icon: string;
    };
    static startProxy(keplr: IKeplr & KeplrCoreTypes, metaId: string | undefined, eventListener?: {
        addMessageListener: (fn: (e: any) => void) => void;
        removeMessageListener: (fn: (e: any) => void) => void;
        postMessage: (message: any) => void;
    }, parseMessage?: (message: any) => any): () => void;
    protected requestMethod(method: keyof (IKeplr & KeplrCoreTypes), args: any[]): Promise<any>;
    protected enigmaUtils: Map<string, SecretUtils>;
    defaultOptions: KeplrIntereactionOptions;
    constructor(metaId: string | undefined, version: string, mode: KeplrMode, onStarknetStateChange: (state: {
        selectedAddress: string | null;
        chainId: string | null;
        rpc: string | null;
    }) => void, onStarknetAccountChange: (state: {
        selectedAddress: string | null;
    }) => void, eventListener: {
        addMessageListener: (fn: (e: any) => void) => void;
        removeMessageListener: (fn: (e: any) => void) => void;
        postMessage: (message: any) => void;
    }, parseMessage: ((message: any) => any) | undefined, eip6963ProviderInfo: EIP6963ProviderInfo | undefined, starknetProviderInfo: {
        id: string;
        name: string;
        icon: string;
    });
    ping(): Promise<void>;
    enable(chainIds: string | string[]): Promise<void>;
    disable(chainIds?: string | string[]): Promise<void>;
    experimentalSuggestChain(chainInfo: ChainInfo): Promise<void>;
    getKey(chainId: string): Promise<Key>;
    getKeysSettled(chainIds: string[]): Promise<SettledResponses<Key>>;
    sendTx(chainId: string, tx: StdTx | Uint8Array, mode: BroadcastMode): Promise<Uint8Array>;
    signAmino(chainId: string, signer: string, signDoc: StdSignDoc, signOptions?: KeplrSignOptions): Promise<AminoSignResponse>;
    signDirect(chainId: string, signer: string, signDoc: {
        bodyBytes?: Uint8Array | null;
        authInfoBytes?: Uint8Array | null;
        chainId?: string | null;
        accountNumber?: Long | null;
    }, signOptions?: KeplrSignOptions): Promise<DirectSignResponse>;
    signDirectAux(chainId: string, signer: string, signDoc: {
        bodyBytes?: Uint8Array | null;
        publicKey?: {
            typeUrl: string;
            value: Uint8Array;
        } | null;
        chainId?: string | null;
        accountNumber?: Long | null;
        sequence?: Long | null;
    }, signOptions?: Exclude<KeplrSignOptions, "preferNoSetFee" | "disableBalanceCheck">): Promise<DirectAuxSignResponse>;
    signArbitrary(chainId: string, signer: string, data: string | Uint8Array): Promise<StdSignature>;
    signICNSAdr36(chainId: string, contractAddress: string, owner: string, username: string, addressChainIds: string[]): Promise<ICNSAdr36Signatures>;
    verifyArbitrary(chainId: string, signer: string, data: string | Uint8Array, signature: StdSignature): Promise<boolean>;
    signEthereum(chainId: string, signer: string, data: string | Uint8Array, type: EthSignType): Promise<Uint8Array>;
    getOfflineSigner(chainId: string, signOptions?: KeplrSignOptions): OfflineAminoSigner & OfflineDirectSigner;
    getOfflineSignerOnlyAmino(chainId: string, signOptions?: KeplrSignOptions): OfflineAminoSigner;
    getOfflineSignerAuto(chainId: string, signOptions?: KeplrSignOptions): Promise<OfflineAminoSigner | OfflineDirectSigner>;
    suggestToken(chainId: string, contractAddress: string, viewingKey?: string): Promise<void>;
    getSecret20ViewingKey(chainId: string, contractAddress: string): Promise<string>;
    getEnigmaPubKey(chainId: string): Promise<Uint8Array>;
    getEnigmaTxEncryptionKey(chainId: string, nonce: Uint8Array): Promise<Uint8Array>;
    enigmaEncrypt(chainId: string, contractCodeHash: string, msg: object): Promise<Uint8Array>;
    enigmaDecrypt(chainId: string, ciphertext: Uint8Array, nonce: Uint8Array): Promise<Uint8Array>;
    getEnigmaUtils(chainId: string): SecretUtils;
    experimentalSignEIP712CosmosTx_v0(chainId: string, signer: string, eip712: {
        types: Record<string, {
            name: string;
            type: string;
        }[] | undefined>;
        domain: Record<string, any>;
        primaryType: string;
    }, signDoc: StdSignDoc, signOptions?: KeplrSignOptions): Promise<AminoSignResponse>;
    getChainInfosWithoutEndpoints(): Promise<ChainInfoWithoutEndpoints[]>;
    getChainInfoWithoutEndpoints(chainId: string): Promise<ChainInfoWithoutEndpoints>;
    __core__getAnalyticsId(): Promise<string>;
    changeKeyRingName({ defaultName, editable, }: {
        defaultName: string;
        editable?: boolean;
    }): Promise<string>;
    __core__privilageSignAminoWithdrawRewards(chainId: string, signer: string, signDoc: StdSignDoc): Promise<AminoSignResponse>;
    __core__privilageSignAminoDelegate(chainId: string, signer: string, signDoc: StdSignDoc): Promise<AminoSignResponse>;
    __core__privilageSignAminoExecuteCosmWasm(chainId: string, signer: string, signDoc: StdSignDoc): Promise<AminoSignResponse>;
    sendEthereumTx(chainId: string, tx: Uint8Array): Promise<string>;
    suggestERC20(chainId: string, contractAddress: string): Promise<void>;
    __core__webpageClosed(): Promise<void>;
    getStarknetKey(chainId: string): Promise<{
        name: string;
        hexAddress: string;
        pubKey: Uint8Array;
        address: Uint8Array;
        isNanoLedger: boolean;
    }>;
    getStarknetKeysSettled(chainIds: string[]): Promise<SettledResponses<{
        name: string;
        hexAddress: string;
        pubKey: Uint8Array;
        address: Uint8Array;
        isNanoLedger: boolean;
    }>>;
    signStarknetTx(chainId: string, transactions: Call[], details: InvocationsSignerDetails): Promise<{
        transactions: Call[];
        details: InvocationsSignerDetails;
        signature: string[];
    }>;
    signStarknetDeployAccountTransaction(chainId: string, transaction: DeployAccountSignerDetails): Promise<{
        transaction: DeployAccountSignerDetails;
        signature: string[];
    }>;
    generateStarknetProvider(): IStarknetProvider;
    getBitcoinKey(chainId: string): Promise<{
        name: string;
        pubKey: Uint8Array;
        address: string;
        paymentType: SupportedPaymentType;
        isNanoLedger: boolean;
    }>;
    getBitcoinKeysSettled(chainIds: string[]): Promise<SettledResponses<{
        name: string;
        pubKey: Uint8Array;
        address: string;
        paymentType: SupportedPaymentType;
        isNanoLedger: boolean;
    }>>;
    signPsbt(chainId: string, psbtHex: string, options?: SignPsbtOptions): Promise<string>;
    signPsbts(chainId: string, psbtsHexes: string[], options?: SignPsbtOptions): Promise<string[]>;
    readonly ethereum: EthereumProvider;
    readonly starknet: IStarknetProvider;
    readonly bitcoin: BitcoinProvider;
}
declare class EthereumProvider extends EventEmitter implements IEthereumProvider {
    protected readonly metaId: string | undefined;
    protected readonly injectedKeplr: () => InjectedKeplr;
    protected readonly eventListener: {
        addMessageListener: (fn: (e: any) => void) => void;
        removeMessageListener: (fn: (e: any) => void) => void;
        postMessage: (message: any) => void;
    };
    protected readonly parseMessage?: ((message: any) => any) | undefined;
    protected readonly eip6963ProviderInfo?: EIP6963ProviderInfo | undefined;
    chainId: string | null;
    networkVersion: string | null;
    selectedAddress: string | null;
    isKeplr: boolean;
    isMetaMask: boolean;
    protected _isConnected: boolean;
    protected _currentChainId: string | null;
    constructor(metaId: string | undefined, injectedKeplr: () => InjectedKeplr, eventListener?: {
        addMessageListener: (fn: (e: any) => void) => void;
        removeMessageListener: (fn: (e: any) => void) => void;
        postMessage: (message: any) => void;
    }, parseMessage?: ((message: any) => any) | undefined, eip6963ProviderInfo?: EIP6963ProviderInfo | undefined);
    protected _requestMethod: <T = unknown>(method: keyof IEthereumProvider, args: Record<string, any>) => Promise<T>;
    protected _initProviderState: () => Promise<void>;
    protected _handleConnect: (evmChainId: number) => Promise<void>;
    protected _handleDisconnect: () => Promise<void>;
    protected _handleChainChanged: (evmChainId: number) => Promise<void>;
    protected _handleAccountsChanged: (selectedAddress: string) => Promise<void>;
    isConnected(): boolean;
    request: <T = unknown>({ method, params, chainId, }: {
        method: string;
        params?: readonly unknown[] | Record<string, unknown> | undefined;
        chainId?: string | undefined;
    }) => Promise<T>;
    enable: () => Promise<string[]>;
    net_version: () => Promise<string>;
}
export declare class BitcoinProvider extends EventEmitter implements IBitcoinProvider {
    protected readonly _injectedKeplr: () => InjectedKeplr;
    protected readonly _eventListener: {
        addMessageListener: (fn: (e: any) => void) => void;
        removeMessageListener: (fn: (e: any) => void) => void;
        postMessage: (message: any) => void;
    };
    protected readonly _parseMessage?: ((message: any) => any) | undefined;
    constructor(_injectedKeplr: () => InjectedKeplr, _eventListener?: {
        addMessageListener: (fn: (e: any) => void) => void;
        removeMessageListener: (fn: (e: any) => void) => void;
        postMessage: (message: any) => void;
    }, _parseMessage?: ((message: any) => any) | undefined);
    protected _requestMethod<T = unknown>(method: keyof IBitcoinProvider, args: Record<string, any>): Promise<T>;
    getAccounts(): Promise<string[]>;
    requestAccounts(): Promise<string[]>;
    disconnect(): Promise<void>;
    getNetwork(): Promise<BitcoinNetwork>;
    switchNetwork(network: BitcoinNetwork): Promise<BitcoinNetwork>;
    getChain(): Promise<{
        enum: BitcoinChainType;
        name: string;
        network: BitcoinNetwork;
    }>;
    switchChain(chain: BitcoinChainType): Promise<BitcoinChainType>;
    getPublicKey(): Promise<string>;
    getBalance(): Promise<{
        confirmed: number;
        unconfirmed: number;
        total: number;
    }>;
    getInscriptions(offset?: number, limit?: number): Promise<{
        total: number;
        list: Inscription[];
    }>;
    signMessage(message: string, type?: BitcoinSignMessageType): Promise<string>;
    sendBitcoin(to: string, amount: number): Promise<string>;
    pushTx(rawTxHex: string): Promise<string>;
    pushPsbt(psbtHex: string): Promise<string>;
    signPsbt(psbtHex: string, options?: SignPsbtOptions): Promise<string>;
    signPsbts(psbtsHexes: string[], options?: SignPsbtOptions): Promise<string[]>;
    getAddress(): Promise<string>;
    connectWallet(): Promise<string[]>;
    protected _handleNetworkChanged: (network: BitcoinNetwork) => Promise<void>;
    protected _handleAccountsChanged: (selectedAddress: string) => Promise<void>;
}
export {};
